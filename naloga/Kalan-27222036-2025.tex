% \documentclass[mat2, tisk]{fmfdelo}
% \documentclass[fin2, tisk]{fmfdelo}
\documentclass[isrm2, tisk]{fmfdelo}
% \documentclass[ped, tisk]{fmfdelo}
% Če pobrišete možnost tisk, bodo povezave obarvane,
% na začetku pa ne bo praznih strani po naslovu, …

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% METAPODATKI
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% LTeX: language=sl-SI

% - vaše ime
\avtor{Tim Kalan}

% - naslov dela v slovenščini
\naslov{Večstranski podpisi}

% - naslov dela v angleščini
\title{Multisignatures}

% - ime mentorja/mentorice s polnim nazivom:
%   - doc.~dr.~Ime Priimek
%   - izr.~prof.~dr.~Ime Priimek
%   - prof.~dr.~Ime Priimek
%   za druge variante uporabite ustrezne ukaze
\mentor{doc.~dr.~Tilen Marc}
% \somentor{...}
% \mentorica{...}
% \somentorica{...}
% \mentorja{...}{...}
% \somentorja{...}{...}
% \mentorici{...}{...}
% \somentorici{...}{...}

% - leto magisterija
\letnica{2025}

% - povzetek v slovenščini
%   V povzetku na kratko opišite vsebinske rezultate dela. Sem ne sodi razlaga
%   organizacije dela, torej v katerem razdelku je kaj, pač pa le opis vsebine.
\povzetek{Tukaj napišemo povzetek vsebine. Sem sodi razlaga vsebine in ne opis tega, kako je delo organizirano.}

% - povzetek v angleščini
\abstract{An abstract of the work is written here. This includes a short description of
the content and not the structure of your work.}

% - klasifikacijske oznake, ločene z vejicami
%   Oznake, ki opisujejo področje dela, so dostopne na strani https://www.ams.org/msc/
\klasifikacija{94A60, 11T71}

% - ključne besede, ki nastopajo v delu, ločene s \sep
\kljucnebesede{kriptografija\sep digitalni podpis\sep Schnorrov podpis\sep večstranski podpis}

% - angleški prevod ključnih besed
\keywords{cryptography\sep digital signature\sep Schnorr signature\sep multisignature} % angleški prevod ključnih besed

% - neobvezna zahvala
% \zahvala{
%   Neobvezno.
%   Zahvaljujem se \dots
% }

% - program dela, ki ga napiše mentor z osnovno literaturo
\programdela{
  Mentor naj napiše program dela skupaj z osnovno literaturo.
}

\osnovnaliteratura{
% Literatura mora biti tukaj posebej samostojno navedena (po pomembnosti) in ne
% le citirana. V tem razdelku literature ne oštevilčimo po svoje, ampak uporabljamo
% ukaz \vnosliterature, v katerega vpišemo citat
  \vnosliterature{micali2001asm}
  % \vnosliterature{gurtin1982introduction}
  % \vnosliterature{zienkiewicz2000finite}
  % \vnosliterature{STtemplate}
}

% - ime datoteke z viri (vključno s končnico .bib), če uporabljate BibTeX
\literatura{literatura.bib}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DODATNE DEFINICIJE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% naložite dodatne pakete, ki jih potrebujete
\usepackage{units}        % fizikalne enote kot \unit[12]{kg} s polovico nedeljivega presledka, glej primer v kodi
\usepackage{graphicx}     % za slike
\usepackage{subcaption}
\usepackage{tikz}
\usetikzlibrary{shapes,calc,positioning,arrows,}

\pgfarrowsdeclarecombine{twotriang}{twotriang}%    double headed arrow
{stealth'}{stealth'}{stealth'}{stealth'} 

% VEČ ZANIMIVIH PAKETOV
% \usepackage{array}      % več možnosti za tabele
% \usepackage[list=true,listformat=simple]{subcaption}  % več kot ena slika na figure, omogoči slika 1a, slika 1b
% \usepackage[all]{xy}    % diagrami
% \usepackage{doi}        % za clickable DOI entrye v bibliografiji
% \usepackage{enumerate}     % več možnosti za sezname

% Za barvanje source kode
% \usepackage{minted}
% \renewcommand\listingscaption{Program}

% Za pisanje psevdokode
\usepackage{algpseudocode}  % za psevdokodo
\usepackage{algorithm}
\floatname{algorithm}{Algoritem}
\renewcommand{\listalgorithmname}{Kazalo algoritmov}

% deklarirajte vse matematične operatorje, da jih bo LaTeX pravilno stavil
% \DeclareMathOperator{\...}{...}

% vstavite svoje definicije ...
\newcommand{\R}{\mathbb R}
\newcommand{\N}{\mathbb N}
\newcommand{\Z}{\mathbb Z}
% Lahko se zgodi, da je ukaz \C definiral že paket hyperref,
% zato dobite napako: Command \C already defined.
% V tem primeru namesto ukaza \newcommand uporabite \renewcommand
\newcommand{\C}{\mathbb C}
\newcommand{\Q}{\mathbb Q}

\newcommand{\todo}[2][]{%
    \textcolor{red}{%
        \\ \textbf{\uppercase{todo: #2}}%
        \\%
        \ifx&#1&% Check if the optional parameter is empty
        \else%
            \textcolor{blue}{\uppercase{ideja:} #1}%
            \\%
        \fi%
    }%
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ZAČETEK VSEBINE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\section{Uvod}
% Napišite kratek zgodovinski in matematični uvod.  Pojasnite motivacijo za problem, kje
% nastopa, kje vse je bil obravnavan. Na koncu opišite tudi organizacijo dela -- kaj je v
% katerem razdelku.
Odkar se je na svetu pojavil koncept (ročnega) podpisa, je večina primerov uporabe temeljila na
pridobivanju podpisov več deležnikov, saj je bila večina podpisanih dokumentov sporazum ali pogodba
med večimi deležniki. Odličen primer je npr.\ Deklaracija neodvisnosti Združenih držav
Amerike, vidna na sliki~\ref{fig:declaration}. 

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.5\textwidth]{images/declaration.jpg}
% \caption[caption za v kazalo]{Dolg caption pod sliko}
  \caption[Deklaracija neodvisnosti Združenih držav Amerike.]{Deklaracija neodvisnosti Združenih 
  držav Amerike s podpisi podpornikov spodaj. Vir slike Wikipedia~\cite{doi}.}
  \label{fig:declaration}
\end{figure}

S pojavom računalnika in napredkom v kriptografiji se je pojavila alternativna oblika podpisovanja.
\textit{Digitalni podpisi} so dandanes povsod. Uporabljeni so vsakič, ko dostopamo do spletnih
strani, prenašamo podatke ali pa opravljamo kakršnakoli plačila. Poleg avtomatiziranih podpisovanj,
ki se zgodijo v ozadju zgoraj omenjenih procesov, pa so digitalni podpisi na voljo tudi kot alternativa
ročnemu podpisu človeka. V praktično vseh pogledih so mnogo varnejši od tradicionalnih podpisov,
omogočajo bolj sistematično preverjanje (prek računalnikov) in so skorajda enostavnejši za uporabo
in prenašanje.

Digitalne podpise sta si prvič zamislila Diffie in Martin Hellman leta $1976$~\cite{diffie1976new},
ko sta predvidevala, da lahko take sisteme ustvarimo na podlagi enosmernih funkcij in asimetrične
kriptografije. Prvi digitalni podpis, ki je bil dejansko implementiran in široko uporabljen, pa je
bil \textit{RSA} podpis, ki so si ga leta $1977$ zamislili Ronald Rivest, Adi Shamir in Leonard
Adleman~\cite{rivest1978rsa}.

Poleg individualnih podpisov, pa lahko digitalne podpise uporabimo tudi za podpisovanje skupin, npr.\
če mora skupina deležnikov podpisati pogodbo. Najenostavneje to dosežemo tako, da vsak član pripne
svoj digitalni podpis. Če je skupina velika, če je računska moč omejena (npr.\ če želimo zmanjšati
ceno transakcij pri tehnologiji veriženja blokov), ali pa če enostavno želimo preverjevalcu podpisov
olajšati delo, lahko poskrbimo, da se skupina podpiše z enim samim, \textit{večstranskim} podpisom.
Ta podpis vseeno priča o vseh podpisnikih, njegova verifikacija oz.\ preverjanje, pa zajema približno
enako dela, kot preverjanje enega samega podpisa.

Taki podpisi so samo en izmed možnih načinov, kako se skupina podpiše. Od ostalih načinov izstopajo
po tem, da omogočajo vpogled v sestavo skupine podpisnikov, kar nudi preverjevalcu več informacij
pri odločanju, če je podpis sprejemljiv, hkrati pa ohranja odgovornost individualnih članov skupine.
Pri tradicionalnih skupinskih podpisih podpis samo priča o podpisu celotne skupine, ustvari pa ga
lahko katerkoli član. Take lastnosti so v določenih primerih zelo zaželene, npr.\ pri tehnologiji
veriženja blokov je zelo pomembno, da je znano iz katerih naslovov prihajajo transakcije. To, v
kombinaciji s popularizacijo Schnorrovega podpisa, je privedlo mnogo raziskovalcev do želje po
večstranskih podpisih, ki vrnejo navadne Schnorrove podpise, in so tako enostavno zamenljivi.

Prva sta si večstranske podpise zamislila Itakura in Nakamura leta $1983$~\cite{itakura1983multi},
vendar takrat še niso videi veliko uporabe. Velik napredek je bil dosežen, ko si je Schnorr leta
$1989$ zamislil Schnorrov podpis~\cite{schnorr1989sig}, ki se je izkazal za posebno primernega za
večstranske podpise. Še vedno pa so bili takšni podpisi zanimivi bolj iz teoretičnega vidika. Leta
$2001$ se je pojavil prvi formalni model in dokaz varnosti za večstranske podpise, zahvaljujoč
Micaliju, Ohti in Reyzinu~\cite{micali2001asm}. Prvi primer široke uporabe se je pojavil z Bitcoinom.
Njegova popularnost je tudi popularizirala raziskovanje večstranskih podpisov, leta $2020$ je izšel
podpis MuSig2~\cite{jonas2020musig2}, ki je bil prvi večstranski podpis, ki je bil primerno učinkovit
za uporabo v Bitcoin omrežju. Široko je uporabljen še danes.

V poglavju~\ref{sec:osnove} najprej predstavimo kriptografske osnove, ki so potrebne za razumevanje besedila.
To zajema modularno aritmetiko in grupe, zgoščevalne funkcije, kriptografijo javnega ključa, nekaj
splošnih definicij pri digitalnih podpisih in potem še nekaj besed o varnosti. V poglavju~\ref{sec:schnorr}
predstavimo Schnorrov podpis, ki je osnova za ostale sheme, ki jih obravnavamo. V 
poglavju~\ref{sec:skpine} predstavimo nekaj možnih pristopov za podpisovanje skupin. Poglavje~\ref{sec:multischnorr}
predstavi večstranski Schnorrov podpis, tam tudi dokažemo njegovo varnost v modelu slučajnega oraklja.
V poglavju~\ref{sec:primerjava} primerjamo učinkovitost navadnega in večstranskega Schnorrovega podpisa.
Na koncu pa v poglavju~\ref{sec:sodobno} omenimo še kako se je področje razvijalo v zadnjem času.

\section{Kriptografske osnove}
\label{sec:osnove}
Preden si lahko natančneje pogledamo, kako lahko skupina ustvari en sam podpis sporočila, si moramo 
pogledati nekaj kriptografskih osnov. Bolj kompleksnejši pojmi bodo opisani sproti, namen tega 
poglavja je predstaviti stvari, ki so predpogoj za branje praktično kakršnegakoli kriptografskega 
besedila s področja digitalnih podpisov.

\subsection{Aritmetika v \texorpdfstring{$\Z_p^*$}{Zp∗}}
V kriptografiji imamo pogosto opravka z multiplikativnimi grupami, najenostavnejša med njimi (in
tudi tradicionalno največ uporabljena) je \textit{multiplikativna grupa naravnih števil modulo $p$},
ki jo označimo $\Z_p^*$. Njeni elementi so števila v $\{0, 1, \dots, p - 1\}$, ki so tuja številu $p$.
V posebnem primeru, ko je $p$ praštevilo, so to torej števila $\{1, 2, \dots, p - 1\}$ in je red grupe
(število elementov) $\text{ord}(\Z_p^*) = |\Z_p^*| = p - 1$. Operacija v tej grupi je, kot ime že
nakazuje, množenje modulo $p$.

Spomnimo se, da je red elementa $g$ v poljubni grupi najmanjše naravno število $q$, da velja $g^q = 1$,
kjer je $1$ enota za množenje. V primeru, da je $p$ praštevilo, je grupa $\Z_p^*$ \textit{ciklična},
kar pomeni, da v njej obstaja element $g$, katerega red je enak redu grupe, torej $\text{ord}(g) = p - 1$.
V tem primeru se $g$ imenuje \textit{generator}.

\begin{primer}[Grupa $\Z_{11}^*$]
\label{primer:Z11}
Ker je $11$ praštevilo, v grupi $\Z_{11}^*$ obstaja generator, oz.\ je grupa ciklična z redom $10 = 
11 - 1$. Z zaporednim računanjem potenc lahko vidimo, da je $\text{ord}(2) = 10$, torej je $2$ 
generator.

\begin{minipage}{0.45\textwidth}
    \begin{align*}
        2^1 &\equiv 2 \pmod{11} \\
        2^2 &\equiv 4 \pmod{11} \\
        2^3 &\equiv 8 \pmod{11} \\
        2^4 &\equiv 5 \pmod{11} \\
        2^5 &\equiv 10 \pmod{11} 
    \end{align*}
\end{minipage}
\begin{minipage}{0.45\textwidth}
    \begin{align*}
        2^6 &\equiv 9 \pmod{11} \\
        2^7 &\equiv 7 \pmod{11} \\
        2^8 &\equiv 3 \pmod{11} \\
        2^9 &\equiv 6 \pmod{11} \\
        2^{10} &\equiv 1 \pmod{11} 
    \end{align*}
\end{minipage}

\end{primer}

\begin{opomba}
    Spomnimo se \textit{kongruence}: $a \equiv b \pmod m \iff m \text{ }|\text{ } a - b$.
\end{opomba}

Za konec tega popdpoglavja si oglejmo še dve trditvi, ki bosta pomembni pri dokazovanju pravilnega
delovanja Schnorrovega podpisa.

\begin{trditev}
\label{trd:mod-q}
    Naj bosta $p$ in $q$ praštevili, kjer $q$ deli $p - 1$, oz.\ $q \text{ }|\text{ } p - 1$. Naj
    bo $g$ element grupe $\Z_p^*$ reda $q$, kar pomeni, da je $g^q \equiv 1 \pmod p$. Naj bo $k$
    naravno število. Potem velja 
    $$ 
    g^k \bmod p = g^{k \bmod q} \bmod p.
    $$
\end{trditev}
\begin{dokaz}
    Po osnovnem izreku o deljenju naravnih števil lahko $k$ na en sam način zapišemo kot $k = nq + r$, 
    kjer velja $n \in \N, r < q$.

    Leva stran enačbe se potem prepiše 
    \begin{align*}
        g^k \bmod p &= g^{nq + r} \bmod p = \\
                    &= (g^q)^n g^r \bmod p = \\
                    &= 1^n g^r \bmod p = \\
                    &= g^r \bmod p,
    \end{align*}
    kjer smo pri prehodu na tretjo vrstico upoštevali, da velja $g^q \equiv 1 \pmod p$. Desno stran
    pa lahko preoblikujemo na naslednji način:
    \begin{align*}
        g^{k \bmod q} \bmod p &= g^{(nq + r) \bmod q} \bmod p = \\ 
                              &= g^r \bmod p.
    \end{align*}
    Ker sta obe strani enaki, je trditev dokazana.
\end{dokaz}

\begin{trditev}
\label{trd:mod-mn-pt}
    Naj bodo $a$, $b$ in $p$ naravna števila. Potem za modularno množenje in potenciranje velja
    \begin{align}
        a \cdot b \bmod p &= (a \bmod p) \cdot (b \bmod p) \bmod p, \label{eq:mod-prod} \\
        a^b \bmod p &= (a \bmod p)^b \bmod p. \label{eq:mod-exp} 
    \end{align}
\end{trditev}
\begin{dokaz}
    $a$ in $b$ lahko po osnovnem izreku o deljenju naravnih števil na en sam način zapišemo kot 
    \begin{align*}
        a &= n_a p + r_a, \\
        b &= n_b p + r_b,
    \end{align*}
    kjer velja $r_a < p$ in $r_b < p$.

    \eqref{eq:mod-prod}: Levo stran preoblikujemo
    \begin{align*}
        a \cdot b \bmod p &= (n_a p + r_a) \cdot (n_b p + r_b) \bmod p = \\
                          &= (n_a n_b p^2 + n_a p r_b + n_b p r_a + r_a r_b) \bmod p = \\
                          &= r_a r_b \bmod p,
    \end{align*}
    desno pa
    \begin{align*}
        (a \bmod p) \cdot (b \bmod p) \bmod p &= (n_a p + r_a \bmod p) \cdot (n_b p + r_b \bmod p) \bmod p = \\
                          &= r_a r_b \bmod p.
    \end{align*}
    Ker se strani ujemata, je trditev dokazana.

    \eqref{eq:mod-exp}: Ker je potenciranje samo zaporedna uporaba množenj, lahko trditev pokažemo z 
    indukcijo na $b$ in enačbo~\eqref{eq:mod-prod}:
    \begin{itemize}
        \item $b = 2$: Primer, ko je $b = 1$ (ali $b = 0$) je trivialen, če pa je $b = 2$, pa se 
            problem reducira v 
            $$ 
            a \cdot a \bmod p \stackrel{?}{=} (a \bmod p) \cdot (a \bmod p) \bmod p,
            $$
            kar drži neposredno po enačbi~\eqref{eq:mod-prod}.
        \item $n \rightarrow n + 1$: Predpostavimo, da enačba~\eqref{eq:mod-exp} drži za $b = n$ (I.P.). 
            Ko je $b = n + 1$, dobimo 
            \begin{align*}
                a^{n + 1} \bmod p &= a^n a \bmod p = \\ 
                                  &\stackrel{\eqref{eq:mod-prod}}{=} (a^n \bmod p) (a \bmod p) \bmod p = \\
                                  &\stackrel{\text{I.P.}}{=} (a \bmod p)^n (a \bmod p) \bmod p = \\
                                  &= (a \bmod p)^{n + 1} \bmod p.
            \end{align*}
    \end{itemize}
    S tem je indukcija končana in trditev dokazana.
\end{dokaz}

\subsection{Zgoščevalne funkcije}
V grobem so (kriptografske) \textit{zgoščevalne funkcije} take funkcije, ki prejmejo poljubno dolg binarni 
niz (ki lahko predstavlja besede, številke, celotne dokumente, \dots), vrnejo pa binarni niz, ki ima
vnaprej določeno dolžino. Tem rezultatom pravimo \textit{zgostitve}. Namen zgoščevalnih funkcij je 
za dokument ustvariti kratek niz, ki zelo verjetno unikatno identificira dokument. Želimo si, da
je v praksi nemogoče najti dva različna niza z enako zgostitvijo, natančno pa zgoščevalne funkcije
definiramo:

\begin{definicija} 
\label{def:hash}
    \textbf{Kriptografska zgoščevalna funkcija} $H: \{0, 1\}^* \rightarrow \{0, 1\}^n$ je funkcija, 
    ki slika binarne nize $m$ poljubne dolžine v njihove \textbf{zgostitve} $H(m)$, tj.\ binarne nize 
    vnaprej določene dolžine $n$. Zadoščati mora naslednjim lastnostim:
    \begin{itemize}
        \item \textbf{Določenost} pomeni, da bo zgoščevanje enakih nizov vedno privedlo do enake 
            zgostitve. Zapišemo lahko $\forall m: ((h_1 = H(m) \wedge h_2 = H(m)) \implies h_1 = h_2)$.
        \item \textbf{Učinkovitost} pomeni, da lahko računalnik izračuna poljubno zgostitev v doglednem 
            času. Izračun zgostitve mora biti računsko učinkovit. Običajno tu zahtevamo, da je časovna
            zahtevnost funkcije $H$ polinomska v dolžini vhodnega niza.
        \item \textbf{Enosmernost} oz.\ \textbf{odpornost na prasliko} pomeni, da iz predložene 
            zgostitve zelo težko ugotovimo, kateri niz je funkcija prejela kot vhod. Če torej poznamo 
            zgostitev $h$ za nek neznan $m$, je računsko neizvedljivo najti niz $m$, da velja $h = H(m)$.
        \item \textbf{Odpornost na drugo prasliko} pomeni, da če poznamo niz in njegovo zgostitev, 
            zelo težko najdemo drug niz z enako zgostitvijo. Če torej poznamo niz $m_1$ z zgostitvijo
            $h_1$, je računsko neizvedljivo najti zgostitev $m_2$, da velja $H(m_2) = h_1$.
        \item \textbf{Skoraj brez trčenj} oz.\ \textbf{odpornost na trčenja} pomeni, da je verjetnost,
            da imata dva izraza enako zgostitev, majhna. Želimo, da je računsko neizvedljivo
            najti dva niza  $m_1$ in $m_2$, ki imata enako zgostitev, oz.,\ da velja $H(m_1) = H(m_2)$.
        \item \textbf{Učinek plazu} pomeni, da vsaka sprememba v vhodnem nizu povzroči veliko spremembo 
            v zgostitvi. Ob katerikoli spremembi se vsak bit zgostitve se spremeni z verjetnostjo 
            vsaj $1/2$.
    \end{itemize}
\end{definicija}

\begin{opomba}
    Vse varne kriptografske zgoščevalne funkcije, ki so v uporabi zadoščajo zgornjim lastnostim. To
    pomeni, da za nobeno od teh funkcij nihče še ni našel trka.
\end{opomba}

\begin{primer}
    Ena izmed najbolj znanih zgoščevalnih funkcij je \texttt{SHA-256}. Njeno ime pomeni \textit{Secure
    Hash Algorithm} (slov.\ varen zgoščevalni algoritem), $256$ pa predstavlja dolžino vrnjene zgostitve.
    Pogostokrat to ime zasledimo pri nameščanju programske opreme, kjer služi kot avtentikator, da smo res
    naložili pravi program. Preverja namreč, da se zgostitvi naloženih in prenešenih datotek ujemajo.

    Za primer si lahko ogledamo zgostitvi dveh podobnih nizov, \textit{Ljubljana} in \textit{Ljubljena}. 
    Kljub podobnosti bomo videli, da sta rezultata popolnoma drugačna, kar si tudi želimo pri zgoščevalnih 
    funkcijah.
    \begin{verbatim}
    SHA-256(Ljubljana) =
    b7f147d8b4a6703a951336654355071f9752385f85d0860379e99b484aee7a82

    SHA-256(Ljubljena) =
    995d2d8ffb40e1838219e65dd2c665701ba34a90e11f7195a4b791838b6787fe
    \end{verbatim}
    Za preglednost nismo prevajali besed v binarne nize, to bi storili npr.\ z \texttt{ASCII} ali \texttt{UTF-8}
    tabelo. Prav tako smo rezultat napisali v šestnajstiškem sistemu, saj je tako krajši. Iz rezultatov
    pa nazorno vidimo učinek plazu, saj sta popolnoma drugačna.
\end{primer}

\subsection{Kriptografija javnega ključa}
Prve šifre, ki smo jih uporabljali ljudje, so bile \textit{simetrične}, kar pomeni, da sta osebi
za komunikacijo obe morali poznati skriven \textit{ključ}, s pomočjo katerega sta tako ustvarjali
šifre, kot jih tudi dešifrirali. Ključ je običajno neko dolgo (binarno) število.

\begin{primer}[Cezarjeva šifra]
    Ena najbolj znanih šifer, ki izvira iz Antičnega Rima, je \textit{Cezarjeva šifra}. Njen ključ 
    je število, ki je krajše od dolžine naše abecede, v Cezarjevem primeru je bilo to število $3$.
    Šifra potem deluje tako, da vsako črko zamakne za toliko mest v abecedi, kolikor definira 
    ključ. Npr.\ za slovensko abecedo, bi šifra zamaknila črke:
    \begin{verbatim}
        A B C Č D E F G H I J K L M N O P R S Š T U V Z Ž
        Č D E F G H I J K L M N O P R S Š T U V Z Ž A B C
    \end{verbatim}
    To bi izraz \texttt{JAVNI KLJUČ} preslikalo v \texttt{MČARL NOMŽF}. Cezarjeva šifra se imenuje 
    tudi \textit{zamična šifra}.
\end{primer}

V prejšnjem stoletju pa se je pojavila alternativa, imenovana \textit{asimetrična kriptografija}, oz.\
\textit{kriptografija javnega ključa}. Glavna prednost te je, da osebi za komunikacijo ne rabita
poznati enakega skrivnega ključa, vendar ima vsak od njiju par ključev, ki ju imenujemo \textbf{javni
ključ} (angl.\ \textit{public key}) in \textbf{zasebni ključ} (angl.\ \textit{secret/private key}) in
označimo kot par $(\text{pk}, \text{sk})$. Vsaka oseba objavi svoj javni ključ in poskrbi, da nihče 
ne izve, kaj je njen zasebni ključ.

Šifriranje potem poteka tako, da pridobimo javni ključ od osebe, s katero želimo komunicirati, ga
uporabimo za šifriranje in objavimo šifrirano sporočilo. Lastnik ustreznega zasebnega ključa (vsakemu
javnemu pripada natanko en zasebni) potem pridobi šifrirano sporočilo in ga z zasebnim ključem
dešifrira. Kriptosistemi delujejo na način, da lahko sporočilo, šifrirano z javnim ključem dešifrira
samo ustrezen zasebni ključ. Tako zagotovimo varno komunikacijo.

\begin{primer}[RSA]
\label{primer:rsa}
    En prvih algoritmov javnega ključa, ki se uporablja še danes, je \textit{RSA}. Njegova varnost izhaja 
    iz (domnevne) težavnosti problema iskanja prafaktorjev velikega števila. Svoj ključ definiramo tako, 
    da si izberemo dve (zelo veliki) praštevili $p$ in $q$, ter ju zmnožimo v $n = pq$. Za primer vzemimo 
    $p = 23$ in  $q = 17$. $n$ je potem enak $391$. Izbrati si moramo še eksponent $e$, vzemimo npr. $e = 3$. 
    Naš javni ključ je potem par 
    $$ 
    (n, e) = (391, 3).
    $$
    Postopek šifriranja poteka tako, da oseba, s katero komuniciramo, izbere sporočilo $m$, npr.\ 
    $m = 10$, pridobi naš javni ključ, in izračuna šifro $c$ kot
    $$
    c = m^e \bmod{n} = 10^3 \bmod{n} = 218.
    $$
    Dogovoriti se moramo še o zasebnem ključu. Za to bomo potrebovali eksponent za dešifriranje $d$,
    tako da bo veljalo 
    $$
    (m^e)^d \equiv 1 \pmod{\varphi(n)},
    $$ 
    kjer $\varphi$ označuje Eulerjevo funkcijo. Iščemo torej multiplikativni inverz eksponenta 
    $e$, modulo $\varphi(n)$. V našem primeru je to $d = 235$. Zasebni ključ je potem 
    $$ 
    (p, q, d) = (23, 17, 235). 
    $$
    Iz zasebnega ključa torej lahko kadarkoli izračunamo javnega, saj enostavno zmnožimo $p$ in $q$ 
    ter izračunamo inverz, v splošnem pa iz $n$ učinkovito ne moremo pridobiti faktorjev $p$ in $q$,
    kar nam zagotavlja varnost.

    Ko prejmemo šifrirano sporočilo $c$, ga dešifriramo tako, da izračunamo
    $$
    m = c^d \bmod{n} = 218^{235} \bmod{391} = 10.   
    $$
\end{primer}

Poleg šifriranja, brez da bi si delili ključ, pa je kriptografija javnega ključa omogočila tudi
\textit{digitalne podpise}. Ti so uporabljeni vsakič, ko pošljemo transakcijo ali dostopamo do katerekoli
spletne strani. Delujejo na podoben način, kot šifriranje z javnim ključem, le da najprej uporabimo
zasebni ključ na sporočilu, prek javnega ključa pa preverjamo veljavnost podpisa. Velikokrat sta šifrianje
in podpisovanje uporabljena hkrati, saj tako pošljemo šifrirano sporočilo, ki ga lahko prebere le oseba,
kateri je namenjeno, hkrati pa lahko preveri, da je res prišlo od nas.

\subsection{Digitalni podpisi}
Ideja \textit{kriptografskih} ali \textit{digitalnih podpisov} (angl.\ \textit{digital signatures}) je,
da služijo kot izboljšava človeškega ročnega podpisa. Za razliko od ročnega podpisa, lahko z digitalnim
dosežemo pravo identifikacijo posameznika, ki temelji na njegovem zasebnem ključu. Tako smo lahko
za digitalno podpisan dokument prepričani, da ga je res podpisal lastnik točno določenega zasebnega ključa
(če predpostavimo, da podpisnik ključa ni posredoval nikomur).

Podpis dokumenta poteka nekoliko drugače, kot pri ročnih podpisih. Pri ročnem podpisu ta postane del
dokumenta, digitalni podpis pa je od njega ločen, vseeno pa nastane s pomočjo zgostitve podpisanega
dokumenta, zato bo podpis za dva različna dokumenta vedno drugačen (dokler uporabimo varno zgoščevalno
funkcijo).

Ostane še vprašanje preverjanja avtentičnosti podpisa. Pri ročnem podpisu to lahko storimo prek 
primerjave z znanim, preverjeno avtentičnim podpisom. Ta postopek je zamuden in nenatančen, veliko 
večino ročnih podpisov je moč ponarediti z nekaj prakse. Preverjanje digitalnega podpisa pa temelji 
na kriptografiji javnega ključa. Ker je podpis nastal s pomočjo podpisnikovega zasebnega ključa,
lahko s pomočjo ujemajočega javnega ključa preverimo avtentičnost.

Da se lažje pogovarjamo o kriptografskih sistemih, je smotrno definirati, kaj točno so deležniki,
kot so podpisnik, preverjevalec in napadalec. V kriptografskih besedilih so pogosto definirani kot
verjetnostni Turingovi stroji, mi pa se bomo izognili tej formalizaciji in se pogovarjali enostavno
o \textit{naključnostnih algoritmih}. To so navadni, deterministični algoritmi, ki imajo dostop do
dodatnega parametra, \textit{vira naključnih bitov} $\omega$. Ta vir si lahko predstavljamo kot zelo
dolg seznam naključnih bitov, ki ga algoritem lahko bere, ko ga potrebuje (npr.\ za generiranje
naključnih števil). Branje je ponavadi enkratno dejanje; ko algoritem prebere bit, mora pri
naslednjem klicu prebrati sosednji bit.

\begin{definicija}
\label{def:digisig}
    \textbf{Digitalni} ali \textbf{kriptografski podpis} $\mathcal{S} = (\mathcal{P}, \mathcal{G},
    \mathcal{S}, \mathcal{V})$ je četvorka učinkovitih algoritmov $\mathcal{P}$ za ustvarjanje parametrov
    podpisa, $\mathcal{G}$ za ustvarjanje ključa, $\mathcal{S}$ za podpisovanje in $\mathcal{V}$ za
    preverjanje podpisa. Definirana je nad končno množico možnih  sporočil $\mathcal{M}$, vrnjeni
    podpis pa leži v končni množici podpisov $\Sigma$.
    \begin{itemize}
        \item $\mathcal{P}$ je algoritem za ustvarjanje javnih parametrov podpisa. Definira grupo $G$,
            ki bo uporabljena pri podpisu. V praksi je ta korak izpuščen, sodelujoči pri podpisu
            uporabijo dobro poznane varne grupe. Formalno pa je to algoritem, ki prejme varnostni
            parameter $k$ in vrne parametre grupe $G$, oz.\
            $$
            G = \mathcal{P}(k).
            $$
        \item $\mathcal{G}$ je naključnostni algoritem za ustvarjanje para ključev $(\text{pk}, \text{sk})$, 
            ki za svoj vhod prejme parametre grupe $G$ (javno dostopni ali pa ustvarjeni prek $\mathcal{P}$).
            Z javnim ključem $\text{pk}$ lahko preverjevalec preveri avtentičnost podpisa, z zasebnim
            ključem $\text{sk}$ pa podpisnik podpisuje. Formalno velja
            $$
            (\text{pk}, \text{sk}) = \mathcal{G}(G).
            $$
        \item $\mathcal{S}$ je naključnostni algoritem, ki za svoja argumenta prejme zasebni ključ $\text{sk}$ 
            in sporočilo $m$, vrne pa podpis $\sigma$ sporočila $m$ z zasebnim ključem $\text{sk}$
            oz.\ 
            $$ 
            \sigma = \mathcal{S}(\text{sk}, m).
            $$
        \item $\mathcal{V}$ je determinističen algoritem, ki preverja veljavnost podpisov. Za svoje argumente
            prejme javni ključ $\text{pk}$, sporočilo $m$ in podpis $\sigma$, vrne $veljaven$, če je podpis 
            veljaven in $neveljaven$, sicer. Velja torej
            $$ 
            \mathcal{V}(\text{pk}, m, \sigma) = 
            \begin{cases}
                veljaven, & \sigma = \mathcal{S}(\text{sk}, m), \\
                neveljaven, & \sigma \neq \mathcal{S}(\text{sk}, m).
            \end{cases}
            $$
    \end{itemize}
\end{definicija}

\subsection{Varnost}
Poglavitna lastnost vsakega kriptosistema je njegova \textit{varnost}. Ker je namen digitalnih podpisov
zagotoviti sogovorniku, da je sporočilo res poslal lastnik zasebnega ključa, je največja varnostna
skrb, da bi \textit{napadalec} lahko ponaredil pošiljateljev podpis in si s tem prisvojil njegovo 
identiteto. To napadalcu lahko uspe na več nivojih, ki so od najmanj do najbolj škodljivega:

\begin{itemize}
    \item \textbf{Eksistencialno ponarejanje} (angl.\ \textit{existential forgery}) pomeni, da obstaja
        sporočilo, za katerega napadalec lahko ustvari ponarejen podpis (torej podpis, pri katerem
        ni bil uporabljen zasebni ključ). To pomeni, da lahko najde vsaj en par sporočila in podpisa
        $(m, \sigma)$, da velja $\mathcal{V}(\text{pk}, m, \sigma) = veljaven$.
    \item \textbf{Selektivno ponarejanje} (angl.\ \textit{selective forgery}) pomeni, da lahko napadalec 
        z nezanemarljivo verjetnostjo podpiše sporočilo, ki mu ga da nekdo drug in ga lastnik zasebnega
        ključa še ni podpisal. Torej, če napadalcu nekdo predloži sporočilo $m$, lahko z nezanemarljivo 
        verjetnostjo najde podpis $\sigma$, da velja $\mathcal{V}(\text{pk}, m, \sigma) = veljaven$.
    \item \textbf{Popoln zlom} (angl.\ \textit{total break}) pomeni, da napadalec pridobi 
        zasebni ključ napadenega in s tem pridobi vse potrebne podatke za podpisovanje poljubnih
        sporočil v njegovem imenu.
\end{itemize}

Poleg zgoraj definiranih \textit{ciljev napadalca}, lahko za vsak kriptosistem definiramo tudi
\textit{model napada}, ki ga zagotavlja shema. Stinson~\cite{stinson2023crypto} definira naslednje
modele:
\begin{itemize}
    \item \textbf{Napad samo s ključem} je napad, kjer napadalec pozna javni ključ žrtve $\text{pk}$. 
        Predpostavimo tudi, da napadalec vedno pozna delovanje sheme za podpisovanje $\mathcal{S}$
        in ima dostop do javnih parametrov podpisa $G$. Z javnim ključem torej lahko preverja
        veljavnost podpisov, ni pa prejel nobenega podpisanega sporočila.
    \item \textbf{Napad z znanimi sporočili} je napad, kjer napadalec poseduje seznam parov sporočil 
        in njihovih podpisov $(m_1, \sigma_1), (m_2, \sigma_2), \dots$, kjer za vsak $i$ velja 
        $\sigma_i = \mathcal{S}(\text{sk}, m_i)$.
    \item \textbf{Napad z izbranimi sporočili} je napad, kjer napadalec podpisniku da seznam sporočil $m_1,
        m_2, \dots$, ta pa mu vrne seznam podpisov, da za vsak $i$ velja $\sigma_i = \mathcal{S}(\text{sk}, 
        m_i)$. Napadalčev cilj je iz predloženih parov izvleči zasebni ključ, ali pa na nek drug način
        podpisati še ne podpisano sporočilo.
\end{itemize}

Ostane nam še pregled \textit{tipov varnosti}, ki jo lahko pričakujemo oz.\ zahtevamo od sheme za
podpisovanje. Takšna shema ne more biti \textit{brezpogojno varna}, kar bi pomenilo, da je tudi z
neomejenimi računskimi zmožnostmi nemogoče ponarediti podpis. To je zato, ker lahko napadalec
sistematično preveri vse podpise za neko sporočilo s pomočjo algoritma $\mathcal{V}$, dokler ne najde
pravega. Pričakujemo pa lahko \textit{računsko varnost}, kar pomeni, da napadalec ne more najti
ponaredka v doglednem času, če ima omejene računske sposobnosti, in/ali pa \textit{dokazljivo varnost},
kar pomeni, da lahko varnost prevedemo na težavnost nekega matematičnega problema. Varnost večine
shem za digitalne podpise temelji prav na (domnevni) težavnosti določenih matematičnih problemov. 

\subsubsection{Temelji varnosti}
V primeru~\ref{primer:rsa} smo omenili, da je varnost algoritma RSA odvisna od težavnosti problema
iskanja prafaktorjev velikega števila. To je le eden izmed mnogih problemov, ki služijo kot osnova
za varnost kriptografskih sistemov. V kriptografiji javnega ključa se pogosto srečamo s cikličnimi
grupami, ki podpirajo množenje. V nadaljevanju bomo pogosto uporabili operacijo množenja, za izračune
tipa 
$$
I = g^s,
$$
kjer je $g$ generator ciklične grupe, $s$ pa zasebni ključ. Zaradi notacije bi morda kdo hitro pomislil,
da lahko zgornjo enačbo obrnemo in $s$ izračunamo kot 
$$ 
s = \log_g(I).
$$
Taki izračuni v (nekaterih) cikličnih grupah žal (ali pa na srečo) niso tako enostavni, prišli smo do
koncepta \textit{diskretnega logaritma}. V diskretnih cikličih grupah, kot je npr.\ $\Z_p^*$, ni koncepta
urejenosti, kar smo videli tudi v primeru~\ref{primer:Z11} z grupo $\Z_{11}^*$, zato nam ">približki"<
logaritma ne pomagajo čisto nič. Za izračun takih logaritmov se moramo zanesti na drugačne metode,
kot za izračun logaritmov v množici realnih števil.

\begin{definicija}[Problem diskretnega logaritma~\cite{boneh2023appcry}]
\label{def:dl}
    Naj bo $G$ ciklična grupa reda $q$, ki jo generira element $g$. Naj bo $h$ naključni element iz 
    grupe $G$. Naj velja $g^x = h$. Eksponent $x$ Potem imenujemo \textbf{Diskretni logaritem (DL)}.

    Zamislimo si igro, kjer izzivalec in nasprotnik kot vhod prejmeta opis grupe $G$ (torej $q \in \N$
    in $g \in G$). Izzivalec potem izbere naključen element $\alpha \in G$ in izračuna $h = g^{\alpha}$.
    $h$ pošlje nasprotniku, ta pa mora odgovoriti nazaj z elementom $\alpha$. To igro imenujemo 
    \textbf{problem diskretnega logaritma (PDL)} (angl.\ \textit{discrete logarithm problem}).

    Pri tej igri nas zanima verjetnost pravilnega odgovora nasprotnika, ki je računsko omejen. S tem 
    mislimo, da ima na voljo polinomsko mnogo časa (glede na velikost grupe). Če je grupa $G$ takšna, 
    da je verjetnost zanemarljiva, pravimo, da za grupo $G$ drži \textit{predpostavka diskretnega 
    logaritma}.
\end{definicija}

Če naš kriptosistem torej živi v ciklični grupi, v kateri je problem diskretnega logaritma težek,
nam to zagotavlja, da iz javnega ključa ni računsko izvedljivo pridobiti zasebnega. To je osnova
za varnost mnogih kriptografskih sistemov, kot sta npr.\ ElGamalov sistem~\cite{elgamal1985elgamal}
in Schnorrov podpis~\cite{schnorr1989sig}.

Preden nadaljujemo, natančneje definirajmo, kaj pomeni, da je verjetnost zanemarljiva.

\begin{definicija}[Zanemarljiva funkcija~\cite{boneh2023appcry}]
    Zanemarljiva funkcija je taka funkcija $\mu : \N \rightarrow \R$, da za vsako število
    $c > 0$ obstaja naravno število $n_0 \in \N$, da za vsak $n > n_0$ velja
    $$
    |\mu(n)| < \frac{1}{n^c}.
    $$
\end{definicija}

To so torej funkcije, ki padajo proti nič hitreje, kot inverz kateregakoli polinoma. V kontekstu
diskretnega logaritma želimo, da je verjetnost izračuna pravilnega odgovora nasprotnika zanemarljiva
v odvisnosti od velikosti grupe.

V besedilu bomo večkrat govorili o ">zanemarljivih verjetnostih"<, kar pomeni, da se bodo
verjetnosti v odvisnosti od določene spremenljivke vedle kot zanemarljive funkcije.

\subsubsection{Model slučajnega oraklja}
Ko obravnavamo varnost kriptosistemov, se ponavadi pogovarjamo o \textit{standardnemu modelu} kriptografije. 
Ta model ima samo eno predpostavko: napadalec je omejen samo s časom in količino računske moči, ki mu 
je na voljo (tu je običajno predpostavljeno, da ima napadalec realno računsko moč). Občasno se znajdemo 
v primeru, ko moramo za dokaz varnosti sprejeti dodatne predpostavke. V tem primeru govorimo o 
alternativnih modelih kriptografije. 

Ko imamo opravka z zgoščevalnimi funkcijami, je pogosto potrebno sprejeti dodatne predpostavke, da lahko 
pokažemo varnost. Specifično, ko imamo opravka z zgoščevalno funkcijo $H: A \rightarrow B$ predpostavimo, 
da je bila ta funkcija izbrana naključno med vsemi funkcijami, ki slikajo $A$ v $B$. To idealizirano 
verzijo zgoščevalne funkcije imenujemo \textbf{slučajni orakelj} (angl.\ \textit{random oracle}).
Za poljuben vhod torej vedno vrne enak odgovor, vendar je bil ta odgovor popolnoma naključno izbran.

\textbf{Model slučajnega oraklja} (angl.\ \textit{random oracle model}) je model kriptografije, kjer poleg 
standardnih predpostavk, vsako uporabo zgoščevalne funkcije nadomestimo s slučajnim 
orakljem~\cite{boneh2023appcry}. Predpostavimo, da imajo do oraklja dostop vsi vpleteni v kriptosistem, 
vključno z napadalcem.

Varnostni dokazi, ki temeljijo na uporabi takih slučajnih orakljev, vseeno pričajo o varnosti shem,
ki namesto orakljev uporabljajo zgoščevalne funkcije, vsaj dokler je uporabljena zgoščevalna funkcija
varna (npr.\ zanjo nihče še ni našel trka).

\subsubsection{Simulatorji}
Pogosto je cilj varnostnih dokazov pokazati, da je varnost neke sheme enakovredna težavnosti nekega
problema, za katerega domnevamo, da je težek. V takih primerih je govorimo o metodi
\textit{dokazovanja z redukcijo} (angl.\ \textit{reduction proof}). Ta metoda temelji na
predpostavki, da če bi napadalec lahko učinkovito napadel shemo, bi lahko tudi učinkovito rešil težaven
problem.

\textit{Simulatorji} so način, kako lahko izpeljemo redukcijo iz napada na reševanje težavnega problema.
To so algoritmi, ki posnemajo delovanje iskrenih podpisnikov ali pa kar celotne kriptografske sheme.
Ideja je, da simulator ne pozna zasebnih ključev, vendar pa za napadalca lahko posnema celotno
delovanje sheme. Cilj dokazov varnosti je pokazati, da če lahko napadalec uspešno izvede napad na
shemo (npr.\ ponaredi podpis ali pa pridobi zasebni ključ), potem lahko simulator uporabi informacije
iz napadalčevega napada, da učinkovito reši domnevno težek problem (npr.\ problem diskretnega logaritma).
Ker domnevamo, da se tega problema ne da rešiti učinkovito, lahko zaključimo, da je shema varna.
Za večino shem so koristni torej le simulatorji, ki delujejo v polinomskem času.

Da je simulator uporaben za dokaz varnosti, mora zadoščati naslednjim lastnostim:
\begin{itemize}
    \item \textbf{Nerazločljivost}: Napadalec ne ve, ali komunicira s pravim podpisnikom ali s
        simulatorjem. Če bi lahko napadalec razlikoval, potem bi lahko zaključili, da shema napadalcu
        razkrije neko skrivnost, saj je prisotnost skrivnosti edina razlika med pravim podpisnikom in
        simulatorjem.
    \item \textbf{Brez skrivnosti}: Simulator ne pozna zasebnih ključev. Ta lastnost je ključna, saj
        nam pove, da napadalec prek interakcije z dejanskim podpisnikom ne izve nobene dodatne informacije.
        Če je napadalec uspešen pri interakciji s simulatorjem ali pa podpisnikom, ki ima zasebni
        ključ, potem smo lahko prepričani, da prisotnost zasebnega ključa ne pomaga pri napadu.
    \item \textbf{Prilagodljivost}: Simulator in napadalec med seboj komunicirata. Pogosto je potrebno,
        da simulator prilagodi svoje odločitve na podlagi napadalčevih odločitev.

        V modelu slučajnega oraklja prilagodljivost dobi dodatno dimenzijo. Simulator poleg
        celotnega protokola simulira tudi delovanje oraklja. To mu omogoča, da napadalca ">previje"<
        na prejšnje stanje, prilagodi odgovor oraklja in ponovno izvede korak sheme.
\end{itemize}

\subsection{Interaktivni protokoli}
V tem razdelku bomo govorili o \textit{interaktivnih protokolih} (angl.\ \textit{interactive protocols}).
To so protokoli, kjer si dva sogovornika izmenjujeta sporočila, dokler ne prideta do skupnega zaključka.
Pogosto se uporabljajo za namene avtentikacije, kjer ena stran dokazuje svojo identiteto drugi.
Zaradi te uporabe, bomo sogovornika poimenovali \textit{dokazovalec} (angl.\ \textit{prover}) in
\textit{preverjevalec} (angl.\ \textit{verifier}). Taki protokoli so sorodni digitalnim podpisom,
pogosto pa so uporabljeni pri konstrukciji bolj zahtevnih kriptografskih shem.

Avtentikacijo lahko vidimo kot poseben primer dokazovanja. Dokazovalec želi dokazati preverjevalcu, da
je res tisti, za katerega se izdaja. Protokoli, kjer je cilj dokazati neko trditev, sodijo v skupino
\textit{interaktivnih sistemov dokazovanja} (angl.\ \textit{interactive proof systems}). Formalno
morajo taki protokoli zadoščati dvema lastnostma:
\begin{itemize}
    \item \textbf{Kompletnost} (angl.\ \textit{completeness}): Če trditev, ki se dokazuje,
        drži, potem bo preverjevalec sprejel dokaz dokazovalca (če noben od njiju ne bo goljufal).
    \item \textbf{Zadostnost} (angl.\ \textit{soundness}): Če trditev, ki se dokazuje, ne
        drži, potem noben dokazovalec (tudi tak, ki goljufa) ne more predložiti dokaza, ki bi 
        ga preverjevalec sprejel, razen z zanemarljivo verjetnostjo.
\end{itemize}
Dejanski interaktivni protokol pa potem deluje kot izmenjava sporočil, kjer dokazovalec poskuša
prepričati preverjevalca, da trditev drži, preverjevalec pa s serijo vprašanj preverja, če je
dokazovalec iskren in če trditev res drži. Pogosto predpostavimo, da ima dokazovalec neomejeno
računsko moč, vendar ni iskren, preverjevalec pa je omejen na polinomsko računsko moč in je iskren.

\begin{primer}[Reševanje sudokuja]
    Za enostaven primer interaktivnega dokaza si oglejmo reševanje posplošenega Sudokuja. Tradicionalni
    Sudoku je problem, kjer moramo v $9 \times 9$ mrežo zapolniti števila od $1$ do $9$ tako, da se v vsaki
    vrstici, stolpcu in $3 \times 3$ kvadratu ne ponovijo nobena števila. Problem posplošimo tako, da
    ga prenesemo na poljubno mrežo velikosti $n^2 \times n^2$ in dovolimo uporabo števil od $1$ do $n^2$.

    Znano je, da je ta problem NP-poln~\cite{yato2003sudoku}, kar pomeni, da je težko najti rešitev,
    vendar je enostavno preveriti, če je rešitev pravilna. Če želi dokazovalec prepričati preverjevalca,
    da zna rešiti vse Sudokuje, lahko to storita tako, da si preverjevalec izbere naključne Sudokuje,
    jih pošlje dokazovalcu, ta pa jih reši in vrne rešitve. Preverjevalec nato preveri, če so rešitve pravilne.
    Po dovolj velikem številu preverjenih Sudokujev, bo preverjevalec lahko prepričan, da dokazovalec
    res zna reševati Sudokuje.
\end{primer}

\begin{opomba}
    Interaktivni sistemi dokazovanja ne proizvedejo pravih dokazev v matematičnem smislu. Vedno
    obstaja določena verjetnost (ki je sicer zanemarljiva), da lahko goljufiv dokazovalec prepriča
    iskrenega preverjevalca o trditvi, ki ne drži. Ker pa je ta verjetnost zanemarljiva, nas to
    dejstvo ne moti.
\end{opomba}

\subsubsection{Dokazi brez razkritja znanja}
\textit{Dokazi brez razkritja znanja} (angl.\ \textit{zero-knowledge proofs}) so posebna vrsta interaktivnih
sistemov dokazovanja, ki poleg kompletnosti in zadostnosti zadoščajo še tretji lastnosti:
\begin{itemize}
    \item \textbf{Brez razkritja znanja} (angl.\ \textit{zero-knowledge}): Če trditev, ki se dokazuje, 
        drži, potem noben preverjevalec (tudi tak, ki goljufa) ne bo iz dokaza izvedel ničesar več, 
        kot samo to, da trditev drži.
\end{itemize}
To je torej orodje, prek katerega lahko dokazovale dokaže, da nekaj ve, brez da bi izdal, kaj to je.

\begin{primer}[Jama Ali Babe~\cite{quisquater1990children}]
    V zgodbi o jami Ali Babe nastopata Ana in Bojan. Živita ob jami Ali Babe, ki je v obliki prstana. 
    Pri vhodu sta na levo in desno vidni dve poti, ki se kasneje združita, vendar prehod preprečujejo 
    vrata, ki jih lahko odpre samo skrivno geslo. Ana je ugotovila, kaj to geslo je, vendar ga ne želi 
    povedati Bojanu, vseeno pa ga želi prepričati, da geslo pozna. 

    Da Ana Bojanu dokaže svoje znanje, si zamisli igro. Najprej bo ona odšla v jamo po eni izmed poti. 
    Potem bo v jamo vstopil Bojan in povedal, če želi, da se Ana vrne po levi ali desni poti. Če se 
    bo Ana dovolj velikokrat vrnila po poti, ki jo je povedal Bojan (in nikoli po napačni), bo lahko 
    z veliko verjetnostjo prepričan, da Ana res pozna geslo. Primer enega kroga protokola je prikazan 
    na sliki~\ref{fig:alibaba}. 
    \begin{figure}[ht]
      \centering
        \begin{subfigure}{0.28\textwidth}
            \includegraphics[width=\textwidth]{images/zkp1.png}
        \end{subfigure}
        \hspace{0.25cm}
        \begin{subfigure}{0.25\textwidth}
            \includegraphics[width=\textwidth]{images/zkp2.png}
        \end{subfigure}
        \hspace{0.25cm}
        \begin{subfigure}{0.25\textwidth}
            \includegraphics[width=\textwidth]{images/zkp3.png}
        \end{subfigure}
        \caption[Jama Ali Babe.]{Igra Ane in Bojana v jami Ali Babe. Vir slike Wikipedia~\cite{zkp}.}
        \label{fig:alibaba}
    \end{figure}
\end{primer}

\subsubsection{Dokazi znanja brez razkritja znanja}
Za namene kriptografije so pogosto zanimivi dokazi brez razkritja znanja. Da vzpostavimo zaupanje
(npr.\ med dvema strankama, ki se ne poznata), pa ne želimo samo, da ena stranka dokaže obstoj neke
skrivnosti, ampak tudi, da to skrivnost dejansko pozna. To je osnovna ideja \textit{dokazov znanja
brez razkritja znanja} (angl.\ \textit{zero-knowledge proofs of knowledge}).

Odličen primer tovrstnega dokaza je dokaz znanja o tem, da poznamo diskretni logaritem dane vrednosti.
Ta dokaz ima neposredno uporabo v kriptografiji, saj tako lahko dokažemo, da nek javni ključ res
pripada nam. Denimo, da smo ustvarili par ključev $(I, s)$, kjer je $I = g^s$ javni ključ, $s$ pa
zasebni ključ. Če nam preverjevalec predloži vrednost $I = g^s$, mi pa ga uspemo prepričati, da poznamo
vrednost $s$, potem je to dovolj, da preverjevalec verjame, da je $I$ res naš javni ključ (razen z
zanemarljivo verjetnostjo).

Dokazovanje dejstva, da nek javni ključ res pripada nam prek interaktivnega protokola ima veliko
uporabno vrednost. Tovrstne dokaze imenujemo \textit{identifikacijski protokoli} oz.\ sheme.

\begin{primer}[Schnorrov identifikacijski protokol]
    En izmed najenostavnejših protokolov za dokaz znanja brez razkritja znanja je Schnorrov
    protokol~\cite{schnorr1989sig}. Tesno je povezan s Schnorrovim podpisom, ki ga bomo spoznali v
    naslednjem razdelku. Protokol poteka med dokazovalcem, ki želi dokazati preverjevalcu, da
    pozna diskretni logaritem dane vrednosti, in preverjevalcem, ki želi to preveriti.

    Pred začetkom se morata strinjati o ciklični grupi $G$ reda $q$, ki jo generira element $g$. Ta
    grupa predstavlja ogrodje za protokol. Prav tako je obema na voljo javni podatek
    $$
    I = g^s \in G.
    $$
    Cilj dokazovalca je, da preverjevalca prepriča, da pozna vrednost $s \in [0, q-1]$, ne da bi mu
    o njej razkril karkoli drugega. Protokol poteka v več korakih:
    \begin{enumerate}
        \item \textbf{Zaveza:}
            Dokazovalec si enakomerno naključno izbere vrednost $r \in [0, q-1]$ in izračuna
            $$
            X = g^r \in G.
            $$
            To vrednost pošlje preverjevalcu.
        \item \textbf{Izziv:}
            Preverjevalec si izbere naključno vrednost $e \in [0, q-1]$ in jo pošlje dokazovalcu.
        \item \textbf{Odgovor:}
            Dokazovalec izračuna odgovor
            $$
            y = r + es
            $$
            in ga pošlje preverjevalcu.
        \item \textbf{Preverjanje:}
            Preverjevalec preveri, če velja
            $$
            g^y = X \cdot I^e.
            $$
            Če enakost drži, preverjevalec verjame, da dokazovalec pozna vrednost $s$, saj je
            $$
            g^y = g^{r + es} = g^r \cdot g^{es} = X \cdot I^e.
            $$
    \end{enumerate}
    Varnost protokola temelji na težavnosti problema diskretnega logaritma in pa na dejstvu, da je
    izziv določen po zavezi. Zato dokazovalec ne more izračunati prepričjivega odgovora, preden
    dobi izziv. Bolj formalno bomo varnost dokazali pri dokazu varnosti Schnorrovega podpisa v
    razdelku~\ref{sec:schnorr-sec}.
\end{primer}

\subsubsection{Fiat-Shamirjeva hevristika}
\label{sec:fiat-shamir}
Dokazi znanja brez razkritja znanja so torej odlično splošno orodje, s katerim se lahko prepričamo
o identiteti sogovornika, ne da bi ta moral razkriti skrivni ključ. V praksi pa je težava, da so
taki protokoli interaktivni, kar pomeni, da zahtevajo neposredno komunikacijo med dokazovalcem in
preverjevalcem. Ta komunikacija je zamudna in draga.

Fiat in Shamir sta leta $1987$~\cite{fiat1987heuristic} predlagala način, kako lahko interaktivne
dokaze znanja spremenimo v neinteraktivne. Osnovna ideja je, da namesto preverjevalca, breme izbire
izziva prenesemo na slučajnega oraklja, do katerega imata dostop tako dokazovalec kot preverjevalec.
Hevristika torej deluje samo v modelu slučajnega oraklja.

\begin{primer}[Schnorrova shema in Fiat-Shamirjeva hevristika]
\label{primer:fiat-shamir}
    S pomočjo Fiat-Shamirjeve hevristike lahko Schnorrovo identifikacijsko shemo spremenimo v
    neinteraktivno, kar praktično neposredno privede do Schnorrovega podpisa, ki ga bomo spoznali
    v naslednjem razdelku.

    Glavna ideja je, da se znebimo preverjevalčevega izziva. Namesto tega dokazovalec uporabi
    oraklja $H$, da pridobi zgostitev iz zaveze $X$ in sporočila $m$, ki ga želi podpisati (ta
    korak tudi veže sporočilo na podpis):
    $$
    e = H(X || m).
    $$
    Na podlagi te zgostitve dokazovalec izračuna odgovor $y = r + es$ in ga pošlje preverjevalcu
    skupaj z vrednostjo $X$ in $e$.

    Preverjevalec ima sedaj dovolj podatkov, da tudi sam izračuna vrednost zgostitve in preveri
    enakost.

    Fiat-Shamirjeva hevristika tu ohranja varnost, saj dokazovalec še vedno ne more izračunati
    prepričljivega odgovora, preden izračuna zavezo (razen, če najde trčenje v $H$). Varnost bomo
    dokazali v razdelku~\ref{sec:schnorr-sec}.
\end{primer}

\section{Schnorrov podpis}
\label{sec:schnorr}
Eden izmed najenostavnejših, dokazano varnih podpisov je \textit{Schnorrov podpis}~\cite{schnorr1989sig}.
Kot vsi podpisi, tudi ta potrebuje štiri algoritme: za ustvarjanje javnih parametrov, ustvarjanje ključa, 
podpisovanje sporočil in preverjanje podpisa.

Čeprav je Schnorr originalno~\cite{schnorr1989sig} opisal podpis v multiplikativnih grupah naravnih
števil modulo $p$, pri njem ni nič, kar bi specifično delalo samo v teh grupah. Zares
je Schnorrov podpis mogoče posplošiti na katerekoli končne grupe, kjer obstaja učinkovit algoritem
za množenje in je problem diskretnega logaritma~\ref{def:dl} težek.
\begin{itemize}
    \item \textbf{Parametri}:
    Naj bo $G$ končna grupa reda $p$. V njej si izberemo element $g$ reda $q$, pri čemer mora
    biti $q$ dovolj veliko praštevilo (njegova velikost je odvisna od varnostnega parametra $k$).
    V splošnem pa sta lahko $p$ in $q$ tudi enaka. Ker računanje potega v podgrupi, ki jo določa $g$,
    se običajno privzame, da je $G$ kar grupa reda $q$, ki jo generira $g$.

    Poleg grupe $G$ si morata podpisnik in preverjevalec izbrati še varno kriptografsko zgoščevalno
    funkcijo $H : \{0, 1\}^* \rightarrow \Z_q$. Za varno funkcijo smatramo vsako, 
    ki zadošča lastnostim iz definicije~\ref{def:hash}. Velikost kodomene te funkcije definira velikost 
    končnega podpisa. Iz zgostitve, dolge $\log_2 q$ bitov, dobimo podpis, dolg $2 \log_2 q$ bitov~\cite{
    stinson2023crypto}.
    \item \textbf{Ključ}:
    Za ustvarjanje ključa si izberemo naključno število $s \in [0, q - 1]$ in izračunamo
    $$
    I = g^s
    $$
    z uporabo učinkovitega algoritma za množenje. Javni ključ $I$ je torej element grupe $G$, zasebni ključ
    $s$ pa je element $\Z_q$. Ker smo predpostavili, da je v grupi $G$ težek problem diskretnega logaritma,
    iz javnega ključa $I$ ni mogoče pridobiti zasebnega ključa $s$.

    \item \textbf{Podpis}:
    Za podpis sporočila $m$ si najprej izberemo naključno število $r \in [0, q - 1]$ in izračunamo
    \textit{zavezo} (angl.\ \textit{commitment})
    $$
    X = g^r.
    $$
    Ta korak je popolnoma enak, kot pri ustvarjanju ključa, vendar ima pomembno razliko. Zasebni
    ključ se ne spreminja, pri izbiri $r$ pa je potrebno paziti, da je ta res naključna, in da se
    $r$ ne ponovi (glej opombo~\ref{opomba:nonce}).

    Potem z uporabo zgoščevalne funkcije $H : \{0, 1\}^* \rightarrow \Z_q$ izračunamo \textit{izziv}
    (angl.\ \textit{challenge})
    $$
    e = H(X || m),
    $$
    kjer ">$||$"< označuje stikanje nizov. Za konec je potrebno izračunati še 
    $$ 
    y = es + r, 
    $$
    podpis sporočila $m$ pa je potem par $(X, y)$ oz.\ 
    $$ 
    \mathcal{S}(s, m) = (X, y).
    $$

    \item \textbf{Preverjanje}:
    Za preverjanje veljavnosti podpisa $(X', y')$ sporočila $m$ je potrebno najprej izračunati
    $$
    e' = H(X' || m)
    $$
    in nato preveriti, če velja
    $$
    g^{y'} \stackrel{?}{=} X' \cdot I^{e'}.
    $$
\end{itemize}

Ker Schnorrov podpis deluje v skoraj poljubnih končnih grupah, je zelo prilagodljiv in uporaben.
V zadnjem času je precej popularna uporaba Schnorrovih podpisov v \textit{eliptičnih grupah}.
Te omogočajo izbiro manjših parametrov, kar naredi podpis bolj časovno in prostorsko učinkovit.

\begin{opomba}
\label{opomba:nonce}
    V primeru, da je enak $r$ uporabljen večkrat, podpisnik tvega, da lahko napadalec iz dveh njegovih
    podpisov izračuna njegov zasebni ključ $s$. Naj bosta $(X_1, y_1)$ in $(X_2, y_2)$ podpisa sporočil
    $m_1$ in $m_2$. Potem velja
    $$
    y_1 - y_2 = e_1 s + r_1 - e_2 s - r_2 = (e_1 - e_2)s + (r_1 - r_2).
    $$
    V primeru, da sta $r_1$ in $r_2$ enaka, lahko napadalec z enostavnim izračunom inverza $(e_1 - e_2)$
    pridobi zasebni ključ $s$ (za izračun $e_1$ in $e_2$ ima napadalec dovolj informacij, saj je
    izbrana zgoščevalna funkcija javna).

    Izkaže se, da je lahko problematična že uporaba generatorja naključnih števil za pridobivanje
    $r$, ki ne vrača enakomerno porazdeljenih števil. Če napadalec dobi dovolj veliko količino
    sporočil in podpisov, lahko v tem primeru reši \textit{problem skritega števila} in pridobi
    zasebni ključ~\cite{tibouchi2017attacks}.
\end{opomba}

\subsection{Varnost Schnorrovega podpisa}
\label{sec:schnorr-sec}
Ko govorimo o varnosti Schnorrovega podpisa, imamo v mislih odpornost sheme proti eksistencialnem
ponarejanju, kjer napadalec lahko za katerokoli sporočilo dobi veljaven podpis. Želimo torej, da
napadalcu ne uspe ponarediti podpisa za nobeno sporočilo, ki še ni bilo podpisano.

Kot omenjeno na začetku poglavja, je varnost Schnorrovega podpisa odvisna od težavnosti problema
diskretnega logaritma. Varnost Schnorrovega podpisa je zato odvisna od varnosti grupe, v kateri deluje.
Cilj tega razdelka je pokazati, da je Schnorrov podpis varen, če je problem diskretnega logaritma
težek.

\begin{definicija}[Varnost Schnorrovega podpisa]
    Za Schnorrov podpis v grupi $G$ pravimo, da je varen, če:
    \begin{itemize}
        \item Je problem diskretnega logaritma v grupi $G$ težek.
        \item Obstaja slučajni orakelj $H$, do katerega imajo dostop vsi deležniki. Z drugimi besedami,
            smo v modelu slučajnega oraklja.
        \item Obstaja napadalec, ki lahko pridobi veljaven podpis $(X, y)$ za katerokoli sporočilo $m$,
            ki ga je podpisnik že podpisal. Vendar pa je verjetnost, da napadalec uspešno ponaredi
            podpis za novo sporočilo $m'$, ki ga podpisnik še ni podpisal, zanemarljiva.
    \end{itemize}
\end{definicija}

Varnost podpisa je mogoče dokazati tako, da pokažemo varnost Schnorrove identifikacijske sheme,
opazimo, da nam uporaba Fiat-Shamirjeve hevristike vrne ravno Schnorrov podpis, in pokažemo, da
je ta transformacija varna. Najprej pa moramo seveda definirati, kaj pomeni, da je identifikacijska
shema varna. V osnovi bomo rekli, da je shema varna, če napadalec ne more prepričati preverjevalca,
da je on pravi dokazovalec, brez da bi poznal zasebni ključ. To mora veljati tudi v primeru, da
napadalec lahko ">posluša"< (torej vidi sporočila) več pogovorov med dokazovalcem in preverjevalcem.

\begin{definicija}[Varnost identifikacijske sheme]
\label{def:id-sec}
    Naj bo $k$ varnostni parameter in $T_{sk}$ orakelj, ki ne prejme nobenega vhodnega podatka, ob klicu
    pa vrne transkript ene izvedbe identifikacijske sheme. Definirajmo \textit{identifikacijski
    eksperiment} $Id_F(k)$:
    \begin{enumerate}
        \item Na podlagi varnostnega parametra se definira par ključev $(I, s)$, kjer je $I$
            javni ključ, $s$ pa zasebni ključ.
        \item Napadalec $F$ prejme javni ključ $I$ in neomejen dostop do oraklja $T_{sk}$.
        \item Napadalec $F$ na poljubni točki pošlje zavezo $X$, v odgovor pa dobi izziv $e$. Tudi
            na tej točki lahko napadalec kliče oraklja $T_{sk}$.
        \item Napadalec $F$ izračuna odgovor $y$. Eksperiment vrne $1$, če velja $g^y = X \cdot I^e$,
            sicer vrne $0$.
    \end{enumerate}
    Identifikacijska shema je varna pred pasivnim napadom (ali samo varna), če je verjetnost, da
    izvedba eksperimenta $Id_F(k)$ vrne $1$, zanemarljiva v varnostnem parametru $k$.
\end{definicija}

\begin{izrek}[Varnost Schnorrove identifikacijske sheme~\cite{katz2014introduction}]
    Naj bo $G$ ciklična grupa, v kateri je problem diskretnega logaritma težek. Potem je Schnorrova
    identifikacijska shema v grupi $G$ varna (napadalec ne more prepričati dokazovalca, da je
    on pravi dokazovalec, brez da bi poznal zasebni ključ).
\end{izrek}

\begin{dokaz}
    Dokaz poteka z redukcijo uspešnega napada na rešitev problema diskretnega logaritma. Naj bo napadalec
    $F$ naključnostni algoritem, ki teče v polinomskem času. Napad poteka podobno, kot opisano v
    identifikacijskem eksperimentu iz definicije~\ref{def:id-sec}.


    Na podlagi napadalca $F$ konstruirajmo algoritem $A$, ki iz uspešnega napada napadalca $F$ na
    Schnorrovo identifikacijsko shemo pridobi rešitev problema diskretnega logaritma. Algoritem $A$
    prejme vse javne parametre sheme $(G, g, q, I)$ kot vhod. Potem algoritem deluje v naslednjih
    korakih:
    \begin{enumerate}
        \item Algoritem $A$ zažene napadalca $F$. Ta med svojim delovanjem kliče oraklja $T_{sk}$,
            ki napadalcu vrača transkripte izvedb identifikacijske sheme. Algoritem $A$ mora te
            odgovore simulirati sam, to pa lahko stori tako, da izvede identifikacijsko shemo v
            obratnem vrstnem redu (začne z veljavnim odgovorom, nato izračuna izziv in zavezo). To
            mu uspe, saj mora namesto izračuna diskretnega logarigma izračunati samo inverzno
            operacijo -- eksponenciranje.
        \item Ko napadalec pošlje zavezo $X$, algoritem $A$ izbere enakomerno naključno število $e_1
            \in [0, q - 1]$, jo pošlje napadalcu $F$, ta pa odgovori z odgovorom $y_1$.
        \item Algoritem $A$ ponovno zažene napadalca $F$ z enakimi parametri (torej tudi enakim
            virom naključnih bitov $\omega$) a z različnim izzivom $e_2 \in [0, q - 1]$. Napadalec
            $F$ v tem primeru vrne odgovor $y_2$.
        \item Če sta oba odgovora veljavna, torej velja
            \begin{align*}
                g^{y_1} &= X \cdot I^{e_1} \text{ in} \\
                g^{y_2} &= X \cdot I^{e_2},
            \end{align*}
            potem lahko algoritem $A$ izračuna rešitev problema diskretnega logaritma kot
            \begin{align*}
                X = g^{y_1} \cdot I^{-e_1} &= g^{y_2} \cdot I^{-e_2} \\
                g^{y_1} \cdot g^{-y_2} &= I^{e_1} \cdot I^{-e_2} \\
                g^{y_1 - y_2} &= (g^s)^{e_1 - e_2} \\
                s &= (y_1 - y_2)(e_1 - e_2)^{-1}
            \end{align*}
    \end{enumerate}

    Da dokažemo varnost, moramo sedaj obravnavati verjetnost uspeha napadalca $F$ in algoritma $A$.
    Naj bo $V(\omega, e)$ indikator, da napadalec $F$ vrne pravilen odgovor pri napadu, če je $e$ izziv
    in $\omega$ naključni vir bitov. Označimo z $\delta_{\omega}$ verjetnost uspeha po izzivu $e$
    pri fiksni vrednosti $\omega$
    $$
    \delta_{\omega} = \text{Pr}_e(V(\omega, e) = 1).
    $$
    S to vrednostjo lahko izrazimo verjetnost uspeha identifikacijskega eksperimenta
    $$
    \text{Pr}(Id_F(k) = 1) = \text{Pr}_{\omega, e}(V(\omega, e) = 1) =
        \sum_{\omega} \text{Pr}(\omega) \cdot \delta_{\omega}.
    $$

    Spomnimo se, da algoritem $A$ uspešno izračuna rešitev problema diskretnega logaritma, če napadalec
    $F$ uspe dvakrat pri različnih izzivih $e_1$ in $e_2$. Potem lahko izrazimo
    \begin{align*}
        \text{Pr}(A \text{ uspe}) &=
            \text{Pr}_{\omega, e_1, e_2}(V(\omega, e_1) = 1 \land V(\omega, e_2) = 1 \land e_1 \neq e_2) \\
                                  &\geq \text{Pr}_{\omega, e_1, e_2}(V(\omega, e_1) = 1 \land V(\omega, e_2) = 1) - \text{Pr}(e_1 = e_2) \\
                                  &= \sum_{\omega} \text{Pr}(\omega) \cdot \delta_{\omega}^2 - \frac{1}{q} \\
                                  &\geq (\sum_{\omega} \text{Pr}(\omega) \cdot \delta_{\omega})^2 - \frac{1}{q} \\
                                  &= \text{Pr}(Id_F(k) = 1)^2 - \frac{1}{q},
    \end{align*}
    kjer smo pri prehodu na predzadnjo vrstico uporabili Jensenovo neenakost~\cite{jensen}.
    Ker pa je uspeh algoritma $A$ ekvivalenten rešitvi problema diskretnega logaritma v polinomskem
    času, problem pa po predpostavki obravnavamo v grupi, kjer je problem diskretnega logaritma težek,
    lahko zaključimo, da je verjetnost uspeha algoritma $A$ zanemarljiva. Ker je velikost grupe $q$
    odvisna od varnostnega parametra $k$, je tudi člen $1/q$ zanemarljiv. Iz tega lahko zaključimo
    tudi, da je verjetnost uspeha napadalca $F$ $\text{Pr}(Id_F(k) = 1)$ zanemarljiva, kar pomeni,
    da je Schnorrov identifikacijski protokol varen.
\end{dokaz}

Kot smo videli v primeru~\ref{primer:fiat-shamir}, lahko Fiat-Shamirjevo hevristiko uporabimo, da
iz Schnorrove identifikacijske sheme pridobimo neinteraktivno verzijo. Če torej lahko pokažemo,
da je ta transformacija varna, smo dokazali varnost Schnorrovega podpisa.

\begin{izrek}[Varnost Fiat-Shamirjeve hevristike~\cite{katz2014introduction}]
    Naj bo $\mathcal{S'}$ Schnorrova identifikacijska shema in $\mathcal{S}$ Schnorrova podpisna
    shema, pridobljena iz $\mathcal{S'}$ z uporabo Fiat-Shamirjeve hevristike. Če je identifikacijska
    shema $\mathcal{S'}$ varna, potem je tudi podpisna shema $\mathcal{S}$ varna, če varnost
    obravnavamo v modelu slučajnega oraklja.
\end{izrek}

\begin{dokaz}
    Naj bo napadalec $F$ na podpisno shemo $\mathcal{S}$ naključnostni algoritem, ki teče v
    polinomskem času. Naj bo število napadalčevih klicev slučajnega oraklja polinomsko omejeno
    v varnostnem parametru $k$. Zgornjo mejo označimo s $q$.

    Brez škode za splošnost predpostavimo, da bo napadalec $F$ vsak klic slučajnega oraklja na
    nekem vhodu opravil največ enkrat. Predpostavimo tudi, da če napadalec $F$ uspešno ponaredi
    podpis $(X, y)$ sporočila $m$, potem je sigurno poklical oraklja $H$ s podatki $X || m$.

    Na podlagi napadalca $F$ na podpisno shemo $\mathcal{S}$ želimo konstruirati napadalca $F'$
    na identifikacijsko shemo $\mathcal{S'}$, ki ima dostop do transkripcijskega oraklja $T_{sk}$
    in javnega ključa $I$. Napadalec $F'$ deluje v naslednjih korakih:
    \begin{enumerate}
        \item Izbere si enakomerno naključno število $j \in [1, q]$.
        \item Požene napadalca $F$ in zanj simulira delovanje podpisne sheme $\mathcal{S}$.
            Ko napadalec $F$ opravi $i$-ti klic oraklja $H$ z vhodom $X_i || m_i$, napadalec $F'$
            odgovori na podlagi vrednosti $i$ in $j$:
            \begin{itemize}
                \item Če je $i = j$, napadalec $F'$ uporabi $X_i$ kot zavezo v identifikacijski
                    shemi, v odgovor dobi izziv $e_i$ in ga pošlje napadalcu $F$ kot odgovor na
                    klic oraklja $H$.
                \item V nasprotnem primeru is izbere enakomerno naključno število $e_i \in [0, q-1]$ in ga
                    pošlje napadalcu $F$ kot odgovor na klic oraklja $H$.
            \end{itemize}
            Ko napadalec $F$ zahteva podpis sporočila $m$, napadalec $F'$ pokliče transkripcijskega
            oraklja $T_{sk}$, ki mu vrne transkript $(X, e, y)$. Par $(X, y)$ vrne kot podpis
            napadalcu $F$.
        \label{step:simulate}
        \item Če napadalec $F$ uspe ponarediti podpis $(X, y)$ sporočila $m$, napadalec $F'$ preveri,
            ali velja $(X, m) = (X_j, m_j)$. Če velja, napadalec $F'$ vrne $y$ kot odgovor.
    \end{enumerate}
    V koraku~\ref{step:simulate} je simulacija podpisne sheme uspešna, saj je izziv $e$ v vsakem
    primeru izbran enakomerno naključno (le iz drugega vira), prav tako je par $(X, y)$ iz
    transkripcijskega oraklja izračunan na enak način kot veljaven podpis. Napadalec $F'$ torej ne
    loči med simulacijo in pravim podpisom. Problem nastane le, če je napadalec $F'$ že definiral
    orakljev odgovor na s podatkoma $X$ in $m$, ko dobi transkript $(X, e', y)$ od transkripcijskega
    oraklja $T_{sk}$. Če $e$ ni enak $e'$, simulacija ne uspe. Verjetnost, da se to zgodi, je
    zanemarljiva.

    Potrdimo še, da je rezultat napada na identifikacijsko shemo smiseln. Če v zadnjem koraku velja
    $(X, m) = (X_j, m_j)$ in napadalec $F$ uspe ponarediti podpis $(X, y)$, potem napadalec $F'$
    res lahko pošlje zavezo $X_j$, v odgovor pa dobi izziv $e_j$, na podlagi katerega napadalec na
    podpis $F$ izračuna odgovor $y$. Ta odgovor je zaradi ujemanja izziva tudi veljaven odgovor
    v zadnjem koraku identifikacijske sheme, kar pomeni, da je napadalec $F'$ uspešno napadel.

    Zadnji korak je, da pogledamo verjetnost uspeha napadalca $F'$. Naj $\delta_k$ označuje verjetnost,
    da pride do neujemanja pri odgovorih oraklja (zgoraj smo videli, da je zanemarljiva). Ker je $j$
    izbran enakomerno naključno, je verjetnost, da velja $i=j$, enaka $1/q$. Verjetnost uspešnega
    napada lahko izrazimo kot
    $$
    \text{Pr}(F' \text{ uspe}) = \frac{1}{q} \cdot (\text{Pr}(F \text{ uspe}) - \delta_k),
    $$
    oz.
    $$
    \text{Pr}(F \text{ uspe}) = q \cdot \text{Pr}(F' \text{ uspe}) + \delta_k.
    $$
    Ker je po predpostavki identifikacijska shema varna, je verjetnost uspeha napadalca $F'$
    zanemarljiva. Prav tako je tudi verjetnost $\delta_k$ zanemarljiva, $q$ pa je polinomska zgornja
    meja, kar pomeni, da je tudi verjetnost uspeha napadalca $F$ zanemarljiva. To pomeni, da je
    Schnorrov podpis varen, če je identifikacijska shema varna.
\end{dokaz}

Ker je varna Schnorrova identifikacijska shema in pretvorba iz identifikacijske sheme v podpisno,
lahko zaključimo, da je Schnorrov podpis varen.

\subsection{Primer: Schnorrov podpis v \texorpdfstring{$\Z_p^*$}{Zp∗}}
Za ilustrativni primer si poglejmo, kako je bil Schnorrov podpis prvotno opisan~\cite{schnorr1989sig}.
Predstavljeni podpis je poseben primer podpisa, opisanega zgoraj, kjer je grupa $G$ multiplikativna
grupa naravnih števil modulo praštevila $p$. Za namene tega dela si ga je posebej koristno pogledati,
saj bo enaka grupa uporabljena tudi pri njegovi večstranski različici v poglavju~\ref{sec:multischnorr}.
\begin{itemize}
    \item \textbf{Parametri}:
    Najprej je potrebno generirati par praštevil $p$ in $q$, tako da $q$ deli $p - 1$. Praštevilo $p$
    definira grupo $\Z_p^*$, ki je multiplikativna grupa celih števil modulo $p$. V tej grupi je potem
    potrebno izbrati element $g$, ki je reda $q$. Za varnost je potrebno, da ima $p$ vsaj $2048$ bitov,
    $q$ pa vsaj $224$ bitov.

    Kot v splošni verziji Schnorrovega podpisa, si morata podpisnik in preverjevalec izbrati še varno
    kriptografsko zgoščevalno funkcijo $H : \{0, 1\}^* \rightarrow \Z_q$.

    \item \textbf{Ključ}:
    Za ustvarjanje para ključev je potreben izbor naključnega števila $s \in [0, q - 1]$
    in izračun 
    $$ 
    I = g^s \bmod p.
    $$
    Ta izračun nam da par ključev
    \begin{align*}
    \text{pk} &= (p, q, g, I), \\
    \text{sk} &= s.
    \end{align*}

    \item \textbf{Podpis}:
    Za podpis enega sporočila mora podpisnik generirati naključno število $r \in [0, q-1]$ in izračunati 
    \textit{zavezo} 
    $$ 
    X = g^r \bmod p.
    $$ 
    Potem z uporabo funkcije $H$ izračunamo \textit{izziv} 
    $$
    e = H(X || m),
    $$
    Za konec je potrebno izračunati še 
    $$ 
    y = es + r \bmod q, 
    $$
    podpis sporočila $m$ pa je potem par $(X, y)$ oz.\ 
    $$ 
    S(s, m) = (X, y).
    $$
    Postopek je torej enak splošni verziji Schnorrovega podpisa, le da je v tem primeru uporabljeno
    modularno množenje.

    \item \textbf{Preverjanje}:
    Za preverjanje veljavnosti podpisa $(X', y')$ sporočila $m$, je potrebno izračunati 
    $$ 
    e' = H(X' || m)
    $$
    in preveriti, če velja 
    \begin{equation}
        g^{y'} \stackrel{?}{\equiv} X' \cdot I^{e'} \pmod p. \label{eq:schnorr-ver}
    \end{equation}
\end{itemize}

Z nekaj modularne aritmetike lahko pokažemo, da enačba~\eqref{eq:schnorr-ver} preverja veljavnost
Schnorrovega podpisa.

Po trditvi~\ref{trd:mod-q} lahko levo stran enačbe za preverjanje Schnorrovega podpisa~\eqref{eq:schnorr-ver}
prepišemo
\begin{align*}
    g^{y'} \bmod p &= g^{es + r \bmod q} \bmod p = \\ 
                   &= g^{es + r} \bmod p. 
\end{align*}
Desno stran enačbe~\eqref{eq:schnorr-ver} pa po trditvi~\ref{trd:mod-mn-pt} lahko prepišemo
\begin{align*}
X' \cdot I^{e'} \bmod p &= g^r \bmod p \cdot (g^s \bmod p)^e \bmod p = \\
                        &\stackrel{\eqref{eq:mod-exp}}{=} (g^r \bmod p) \cdot (g^{es} \bmod p) \bmod p = \\ 
                        &\stackrel{\eqref{eq:mod-prod}}{=} g^{es + r} \bmod p,
\end{align*}
kjer smo pri prehodu v drugo vrstico uporabili lastnost~\eqref{eq:mod-exp}, pri prehodu v tretjo 
pa lastnost~\eqref{eq:mod-prod}. Ker se obe strani ujemata za veljavne podpisne vrednosti, ta enačba 
res preverja Schnorrov podpis.

\section{Pregled skupinskih podpisov}
\label{sec:skpine}
Ko pridemo do podpisovanja skupin, si lahko zamislimo več različnih rešitev. Micali~\cite{micali2001asm} 
definira dve lastnosti oz.\ spektra, ki jim lahko zadošča podpis skupine:
\begin{itemize}
    \item \textbf{Prilagodljivost} (angl.\ \textit{flexibility}): Popolnoma prilagodljiv podpis skupine
        je takšen, ki ga lahko proizvede katerakoli podskupina originalne skupine podpisnikov. Ko je podpis 
        preverjen, se mora tisti, ki ga je preveril, odločiti, če je ustrezen del skupine podal svoj podpis. 
        Popolnoma neprilagodljiv podpis bi bil takšen, ki ga lahko ustvari le celotna skupina ali pa
        katerkoli član v imenu celotne skupine.
    \item \textbf{Odgovornost} (angl.\ \textit{accountability}): Če lahko iz podpisa ugotovimo, kateri člani 
        so sodelovali pri ustvarjanju, nam podpis omogoča odgovornost. Ta lastnost je lahko zaželena, če 
        se želimo prepričati, ali je ustrezen del skupine sodeloval pri podpisu (npr.\ ali je pri podpisovanju 
        sodeloval generalni direktor podjetja). V drugih primerih pa si želimo anonimnost posameznih članov 
        (npr.\ če bi generiranje podpisa predstavljalo nekakšno tajno glasovanje, bi želeli vedeti samo, koliko 
        članov je sodelovalo).
\end{itemize}

V nadaljevanju bomo skupino potencialnih podpisnikov (torej podpisnikov, ki imajo možnost sodelovati pri 
podpisovanju) označili s $P = P_1, \dots, P_L$, kjer ima skupina $L$ članov. Dejanski podpis pa bo 
ustvaril samo del skupine $S \subseteq P$.

\subsection{Skupinski podpisi}
\textbf{Skupinski podpis} (angl.\ \textit{group signature}) v imenu celotne skupine $P$ ustvari en 
anonimen član. To torej pomeni, da je podpis popolnoma neprilagodljiv, saj ni možno prisiliti skupine,
da bi podpis ustvaril več kot en član. Prav tako v splošnem noben član, niti tisti, ki preverja podpis,
ne more ugotoviti, kdo je podpis ustvaril. Da skupinski podpisi omogočijo vsaj delno odgovornost, 
skupina določi \textit{vodjo skupine}, ki ima možnost razkriti identiteto podpisnika, če pride do 
težav. V tem primeru seveda vodja predstavlja atraktivno tarčo za napad. Skupinske podpise sta si
zamislila Chaum in van Heyst~\cite{chaum1991group}.

\begin{primer}
    Skupinski podpisi so zelo uporabni v primerih, ko moramo vedeti samo, da neka oseba pripada skupini.
    Primer je recimo dostop do varovanih območij, kjer je neprimerno, da bi natančno sledili vsem
    posameznikom, vseeno pa mora biti dostop omejen samo zaposlenim.
\end{primer}

\subsection{Pragovni podpisi}
Če želimo zagotoviti, da se s podpisom strinja zadosten delež skupine, lahko uporabimo \textbf{pragovni 
podpis} (angl.\ \textit{threshold signature}). Ta nam omogoča določeno mero prilagodljivosti, saj lahko 
katerikoli zadosten delež skupine ustvari podpis. Še vedno je nemogoče upoštevati morebitno hierarhično
strukturo skupine. Po definiciji pragovnih podpisov, ti ne omogočajo odgovornosti, nekateri celo
zagotavljajo popolno anonimnost podpisnikov.

Večina pragovnih podpisov temelji na interpolaciji polinoma $(l - 1)$-stopnje z $l$ točkami. Podpis je 
potem ustvarjen s pomočjo vrednosti polinoma v neki točki. Po interpolaciji se informacija o tem, točno 
katere točke smo uporabili, izgubi. Take podpise imenujemo tudi \textit{$l$-od-$L$ sheme}.

\begin{primer}
    Denimo, da ima banka sef, v katerem hrani vse pomembne dokumente in denar. Zaradi
    izjemne pomembnosti sefa si ne želimo, da bi ga lahko odprla katerakoli posamezna oseba. Če 
    osebje banke uporabi pragovni podpis, lahko zagotovi, da je pri odpiranju sefa vedno prisotnih
    več ljudi, vseeno katerih. Vsak zaposleni dobi točko interpolacije, ko se jih zbere dovolj,
    lahko skupaj ugotovijo vrednost polinoma v vnaprej določeni točki in odklenejo sef.
\end{primer}

\subsection{Večstranski podpisi}
\label{sec:multisig}
Za nekatere uporabe podpisov, bi si od njih želeli podobne lastnosti, kot jih ima večstranski ročen podpis. 
Pri njem lahko hitro preberemo podpisnike, torej imamo popolno prilagodljivost. Vidimo lahko seznam 
podpisnikov, torej lahko presodimo, če so med njimi tisti, ki smo jih želeli. Prav tako podpisniki nosijo 
popolno odgovornost, saj na papirju piše njihovo ime. 

Podoben učinek bi z digitalnimi podpisi lahko dosegli, če bi namesto enega podpisa skupine, od članov 
zbrali individualne podpise in jih nanizali v seznam. Dobili bi torej digitalni podpis skupine, ki 
ponuja popolno prilagodljivost in odgovornost. Težava je samo, da je dolžina podpisa (in s tem čas 
preverjanja) proporcionalna številu podpisnikov. \textbf{Večstranski podpisi} (angl.\textit{multisignatures})
ohranijo lastnosti seznama podpisov, rezultat sheme je pa en sam podpis, ki je enako dolg ne glede 
na število podpisnikov, prav tako je od števila neodvisen čas preverjanja. Tega s seznamom podpisov 
ni mogoče doseči, saj tako dolžina podpisa, kot čas preverjanja podpisa rasteta linearno s številom 
podpisnikov (vsak doda en podpis seznamu, ki ga je potrebno preveriti). Večstranski podpisi so torej 
odlična posplošitev ročnih podpisov skupin, ki vseeno ohrani učinkovito preverjanje.

\begin{primer}
    Recimo, da imamo nek organ, ki izdaja certifikate avtentičnosti uporabnikov (npr.\ potrjuje 
    avtentičnost javnih ključev). Za večjo robustnost in varnost, je lahko ta organ razporejen 
    na več strežnikov. Tako preprečimo razpad sistema v primeru izpada enega strežnika. Zato je 
    torej tudi pomembno, da certifikacijo uporabnika potrdi nekaj strežnikov, ne pa nujno vsi. 
    Tu lahko torej neka podskupina vseh strežnikov organa skupaj izda en večstranski podpis, ki 
    potrjuje avtentičnost uporabnika.
\end{primer}

\subsection{Agregirani podpisi}
Agregirani podpisi imajo zelo podobne lastnosti kot večstranski. Poleg standardnih algoritmov pri digitalnih
podpisih za ustvarjanje parametrov $\mathcal{P}$, ustvarjanje ključev $\mathcal{G}$, podpisovanje 
$\mathcal{S}$ in preverjanje $\mathcal{V}$, imajo agregirani podpisi (angl.\ \textit{aggregate signatures})
še dodaten algoritem za združevanje podpisov $\mathcal{C}$. Ta algoritem prejme seznam trojic javnih
ključev, sporočil in podpisov, vrne pa en sam podpis. Od večstranskih podpisov se razlikuje po tem,
da sporočila niso nujno vsa enaka~\cite{boneh2011aggregate}.

\begin{primer}
    Recimo, da avtentičnost ključev posameznih podpisnikov preverja niz centrov za certificiranje
    podpisov, kjer vsak naslednji center jamči za avtentičnost centra pod njem. Prvi center zajamči
    avtentičnost našega ključa, naslednji zajamči avtentičnost centra in tako naprej. Ko bi želel
    nekdo prejeti naš certificiran javni ključ, bi moral preveriti veljavnost podpisov vseh centrov,
    s pomočjo agregiranih podpisov bi to lahko storil z enim samim preverjanjem.
\end{primer}

\section{Večstranski Schnorrov podpis}
\label{sec:multischnorr}
Micali et al.~\cite{micali2001asm} so prvi definirali formalni model za večstranske podpise in podali
formalni dokaz varnosti za podpisno shemo v tem modelu. Zamislili so si formalni model za večstranske
podpise, in ga poimenovali \textbf{večstranski podpis podskupine z odgovornostjo} (angl.\
\textit{Accountable-Subgroup Multisignature (ASM)}). V tem razdelku predstavimo njihov model, primer
večstranskega podpisa, ki temelji na Schnorrovem podpisu, in argumentiramo varnost podpisa oz.\
modela na sploh.

\subsection{Večstranski podpis podskupine z odgovornostjo}
Kljub daljšemu imenu, večstranski podpis podskupine z odgovornostjo le predstavlja formalni model za
večstranske pospise, predstavljene v razdelku~\ref{sec:multisig}. Ideja oz.\ cilj večstranskega
podpisa je torej, da lahko katerakoli podskupina podpisnikov $S$, neke skupine $P$, brez potrebe po
\textbf{centru zaupanja} (angl.\ \textit{trusted third party (TTP)}) ustvari podpis. Generiranje
ključev je torej popolnoma v domeni skupine $P$. Podpis, ki ga ustvari $S$ predstavlja splošno
preverljiv dokaz strukture $S$ in dejstva, da vsak član skupine stoji za (torej podpisuje) sporočilom
$m$. V tem razdelku predstavimo osnovno idejo ASM.

\begin{definicija}[Večstranski podpis podskupine z odgovornostjo]
\label{def:asm}
    Skupina $P$ je sestavljena iz $L$ podpisnikov, torej
    $$
    P = P_1, P_2, \dots, P_L.
    $$
    Podpisnik predstavlja naključnostni polinomski algoritem. Vsak podpisnik pozna svojo 
    identifikacijsko številko (eno od števil $1, \dots, L$) in pa \textit{varnostni parameter} $k$,
    ki je enak za vse podpisnike.

    Kot vsi digitalni podpisi iz definicije~\ref{def:digisig}, ima tudi ta štiri glavne komponente:
    \begin{itemize}
        \item $\mathcal{P}$ je algoritem za ustvarjanje parametrov. Pognan je samo enkrat, na začetku
            sodelovanja. Vrne parametre $(G, q, g)$, kjer je $G$ grupa reda $q$, ki jo generira
            $g$. Velikost parametrov je odvisna od varnostnega parametra $k$. Velja torej
            $$
            \mathcal{P}(k) = (G, q, g).
            $$
        \item $\mathcal{G}$ je algoritem za ustvarjanje ključev. Za neko skupino podpisnikov $P$ je pognan samo
            enkrat, na začetku sodelovanja. Vsak podpisnik $P_i$ dobi kot vhod seznam vseh podpisnikov v $P$
            in požene $\mathcal{G}$, ki vrne par ključev $(\text{pk}_i, \text{sk}_i)$. Zapišemo lahko torej
            $$
            \mathcal{G}_i(L) = (\text{pk}_i, \text{sk}_i),
            $$
            kjer smo brez škode za splošnost predpostavili, da velikost skupine $L$ enolično opiše
            skupino $P$ (npr.\ vsak podpisnik je predstavljen z indeksom v skupini).
        \item $\mathcal{S}$ je protokol za podpisovanje. Pognan je vsakič, ko neka podskupina $S$ želi
            ustvariti podpis. Vsak podpisnik kot vhod prejme seznam vseh podpisnikov $S$, njihove
            javne ključe $\text{pk}_j$, kjer $j$ teče po identifikacijskih številkah vseh članov $S$,
            sporočilo $m$ in lasten zasebni ključ $\text{sk}_i$. Algoritem $\mathcal{S}$ je porazdeljen
            protokol, pri izvedbi morajo sodelovati vsi člani $S$, ki med seboj komunicirajo. Po
            uspešni izvedbi lahko en od članov objavi podpis $\sigma$.
        \item $\mathcal{V}$ je algoritem za preverjanje veljavnosti podpisa. Požene ga tisti, ki želi 
            preveriti veljavnost večstranskega podpisa. Ni nujno, da je to eden izmed podpisnikov iz $P$. 
            Kot vhod algoritem dobi seznam podpisnikov $S$, pripadajoče javne ključe, sporočilo $m$ in 
            morebiten podpis $\sigma$. Algoritem potem vrne
            $$ 
            \mathcal{V}((id_1, \dots, id_l), (\text{pk}_{id_1}, \dots, \text{pk}_{id_l}), m, \sigma) = 
            \begin{cases}
                veljaven, & \text{podpis veljaven}, \\
                neveljaven, & \text{sicer}.
            \end{cases}
            $$
    \end{itemize}
\end{definicija}

\subsubsection{Robustnost, varnost in napadalec}
Večstranski podpis iz definicije~\ref{def:asm} ni \textit{robusten}. To pomeni, da v primeru izpada
jenega od podpisnikov $P_i$, ki je del podskupine $S$, ta ne more ustvariti večstranskega podpisa.
Podpis še vedno lahko ustvari $S \setminus \{P_i\}$. Ker pri končni shemi ne iščemo robustnosti,
lahko definiramo zelo močnega napadalca, ki ima velik vpliv na celoten sistem.
\begin{definicija}[Napadalec pri ASM]
\label{def:asm-napadalec}
    Napadalca v modelu večstranskih podpisov podskupine z odgovornostjo bomo označili z $F$. Ima
    naslednje zmožnosti:
    \begin{itemize}
        \item Ima popoln nadzor nad vsemi komunikacijskimi kanali med člani skupine $P$. Lahko bere,
            spreminja in preprečuje dostavo vseh sporočil. Prav tako lahko v imenu kateregakoli
            podpisnika pošlje sporočilo.
        \item Kadarkoli lahko \textit{pokvari} kateregakoli podpisnika. Ko je podpisnik pokvarjen,
            napadalec izve njegovo celotno notranje stanje, vključno z vsemi skrivnostmi.
        \item Nadzira lahko vhod algoritma za ustvarjanje ključev $\mathcal{G}$ za vse podpisnike.
            Vsakemu lahko poda drugačno skupino $P$.
        \item Od kateregakoli nepokvarjenega podpisnika lahko kadarkoli zahteva podpis nekega sporočila
            skupaj s podskupino, ki jo določi napadalec. To sposobnost imenujemo
            \textit{napad z izbranim sporočilom in podskupino}.
    \end{itemize}
\end{definicija}

Zaradi obširnih zmožnosti napadalca, ta lahko vedno prepreči podpis sporočila. Naš cilj, kar se
tiče varnosti, je, da preprečimo eksistencialno ponarejanje podpisa. Želimo torej, da napadalec ni
zmožen ponarediti podpisa za katerokoli sporočilo v imenu katerekoli podskupine.

\begin{definicija}[Varnost pri ASM]
\label{def:asm-varnost}
    Naj bo $k$ varnostni parameter (ki si ga delijo vsi podpisniki). Naj bo $c > 0$ poljubna konstanta. 
    Naj bo $F$ napadalec, ki ustreza definiciji~\ref{def:asm-napadalec}, torej lahko nadzoruje in
    spreminja dejanja podpisnikov skupine $S$. Naj bo njegova računska moč omejena s polinomskim časom
    v parametru $k$. Naj bo $p$ verjetnost, da napadalec $F$ vrne trojico $(\sigma, m, S)$, za katero velja: 
    \begin{itemize}
        \item $\sigma$ je veljaven večstranski podpis sporočila $m$ s strani skupine $S$.
        \item Obstaja nepokvarjen podpisnik $P_j$ iz skupine $S$, od katerega napadalec $F$ ni zahteval podpisa 
            sporočila $m$ s strani skupine $S$.
    \end{itemize}
    Shemi za večstranske 
    podpise podskupine z odgovornostjo bomo rekli, da je \textbf{varna}, če je verjetnost $p$ zanemarljiva,
    oz.\ velja
    $$ 
    p < k^{-c}.
    $$
\end{definicija}

Kot je standardno pri varnostni obravnavi digitalnih podpisov, tudi tu predpostavimo, da preverjevalec
kljub močnemu napadalcu lahko vedno pridobi prave javne ključe podpisnikov iz $S$. To pomeni, da
v času preverjanja pozna prave identitete podpisnikov, tudi če napadalec lahko doseže, da podpisniki
v času podpisovanja ne vedo zares, s kom podpisujejo (ne morejo zaupati, da res sodelujejo s člani
podskupine $S$, saj napadalec nadzira komunikacijo).

\subsubsection{Slučajni orakelj pri ASM}
Varnostna obravnava shem za večstranske podpise podskupine z odgovornostjo zahteva model slučajnega
oraklja. Zato predpostavimo, da je $k_2$ še en varnostni parameter. Vsi člani skupine $P$ in
napadalec imajo dostop do slučajnega oraklja $H: \{0, 1\}^* \rightarrow \{0, 1\}^{k_2}$, ki je
naključno izbrana funkcija med vsemi funkcijami, ki slikajo med $\{0, 1\}^*$ in $\{0, 1\}^{k_2}$.

\subsection{Konstrukcija večstranskega Schnorrovega podpisa}
V nadaljevanju bomo konstruirali večstransko verzijo Schnorrovega podpisa, predstavljenega v
poglavju~\ref{sec:schnorr}. Končna shema spada med večstranske podpise podskupin z odgovornostjo.
Ideja konstrukcije je, da začnemo z naivno verzijo, nato pa rešimo njene probleme, kar nas
privede do formalne definicije v razdelku~\ref{sec:def_multi_schnorr} in dokaza varnosti v
razdelku~\ref{sec:proof_multi_schnorr}.

\subsubsection{Naivna verzija}
Vsi podpisniki v skupini $P$ poznajo skupne parametre $p, q$ in $g$. Vsak podpisnik $P_i$ si 
neodvisno in naključno izbere skrivno število $s_i \in [0, \dots q-1]$ in izračuna 
$$ 
I_i = g^{s_i} \bmod p.
$$
Tako vsak podpisnik ustvari svoj par ključev
\begin{align*}
    \text{pk}_i &= (p, q, g, I_i), \\
    \text{sk}_i &= s_i.
\end{align*}

Poljubna podskupina $S =\{P_{id_1}, \dots, P_{id_l}\}$ skupine $P$ podpiše sporočilo $m$ s tremi 
krogi komunikacije:
\begin{enumerate}
    \item Vsak podpisnik $P_i$ iz podskupine $S$ si izbere naključen element $r_i \in [0, q-1]$ 
        in izračuna zavezo 
        $$ 
        X_i = g^{r_i} \bmod p.
        $$
        Podpisniki potem pošljejo svoje zaveze izbranemu podpisniku $D$. 
    \item $D$ izračuna \textit{skupno zavezo} 
        $$ 
        \tilde{X} = (X_{id_1} \cdot X_{id_2} \cdot \cdots \cdot X_{id_l}) \bmod p.
        $$
        in jo pošlje vsem podpisnikom.
    \item Vsak podpisnik s pomočjo slučajnega oraklja izračuna izziv 
        $$ 
        e = H(\tilde{X} || m || S)
        $$
        in svoje \textit{individualne podpise} 
        $$ 
        y_{id_i} = e s_{id_i} + r_{id_i} \bmod q.
        $$
        Individualni podpisi so potem spet poslani podpisniku $D$, ta pa sedaj lahko 
        izračuna 
        $$ 
        \tilde{y} = (y_{id_1} + y_{id_2} + \cdots + y_{id_l}) \bmod q 
        $$
        in vrne končen večstranski podpis
        $$ 
        \sigma = (\tilde{X}, \tilde{y}).
        $$
\end{enumerate}

Preverjanje veljavnosti podpisa je podobno kot pri navadnemu Schnorrovemu podpisu. Da preverimo 
podpis $(\tilde{X}', \tilde{y}')$ sporočila $m$ najprej izračunamo 
$$ 
e' = H(\tilde{X}' || m || S)
$$ 
in preverimo, če velja 
\begin{equation}
\label{eq:naive-ver}
g^{\tilde{y}'} \stackrel{?}{\equiv} \tilde{X}' \cdot \left(\prod_{P_i \in S} I_i \right)^{e'} \pmod p.
\end{equation}

\subsubsection{Generiranje parametrov in Predpostavka DL}
Micali et al.~\cite{micali2001asm} so izpostavili in rešili več problemov z zgornjo naivno idejo.
Prvi problem se pojavi pri generiranju skupnih parametrov javnega ključa $p, q$ in $g$. Ker si podpisniki
delijo samo varnostni parameter $k$ in pa slučajnega oraklja $H$, morajo za parametre uporabiti
$H$ na vnaprej dogovorjen način. Napadalec bo tako poznal točen postopek ustvarjanja skupnih
parametrov, kar mu potencialno da prednost. Izkaže se, da lahko s primerno uporabo $H$ poskrbimo,
da to ne predstavlja nevarnosti. Za generiranje lahko uporabimo standarden algoritem za pridobivanje
praštevil~\ref{alg:gen}.
\begin{algorithm}
    \caption{Algoritem $GenPrimes(k)$ za generiranje praštevil.}
    \label{alg:gen}
    \begin{algorithmic}
        \State $q \gets \text{naključno izbrano $k$-bitno število}$
        \State $p \gets 2q + 1$
        \While{$q$ ni praštevilo in $p$ ni praštevilo}
            \State $q \gets \text{naključno izbrano $k$-bitno število}$
            \State $p \gets 2q + 1$
        \EndWhile
        \State \Return{$p, q$}
    \end{algorithmic}
\end{algorithm}

Ker pa je pri uporabi kriptografije standardno, da se uporabi znane, vnaprej definirane grupe, se
s problemom generiranja parametrov ne bomo ukvarjali. Enostavno predpostavimo, da imajo podpisniki
dostop do skupnih, varnih parametrov.

Ker podpis temelji na Schnorrovem, varnost temelji na težavnosti diskretnega logaritma. Predpostavka
o varnosti je standardna predpostavka diskretnega logaritma, prilagojena za multiplikativne grupe
$\Z_p^*$.

\begin{definicija}[Predpostavka diskretnega logaritma pri ASM]
\label{def:asm_dlp}
    Naj bo $A$ poljuben naključnostni algoritem, ki teče v polinomskem času in svoje parametre sprejme 
    \begin{itemize}
        \item praštevili $p$ in $q$, da velja $p = 2q + 1$ in $q$ je dolg $k$-bitov,
        \item naključni element $g \in \Z_p^*$ reda $q$,
        \item naključni element $I$ iz podgrupe $\Z_p^*$, ki jo generira $g$.
    \end{itemize}
    Naj $p_k^A$ označuje verjetnost, da $A$ vrne $s \in [0, q - 1]$, tako da velja
    $$
    I \equiv g^s \pmod p.
    $$
    Potem za vsako konstanto $c > 0$ in za vsak dovolj velik $k$ velja, da je verjetnost $p_k^A$
    zanemarljiva, oz.\
    $$ 
    p_k^A < k^{-c}.
    $$
\end{definicija}

Pri obravnavi večstranskega Schnorrovega podpisa bomo torej predpostavili, da drži definicija~\ref{def:asm_dlp}.

\subsubsection{Napad na generiranje ključev}
Naslednja težava nastopi v obliki napada v fazi generiranja ključev. Ker napadalec nadzoruje vso
komunikacijo, lahko v tej fazi enostavno počaka, da vsi podpisniki ustvarijo svoje ključe. Na tej
točki napadalec stopi v vlogo zadnjega podpisnika $P_L$ in generira nov par ključev.
Če si torej izbere naključen $s \in [0, q- 1]$, lahko izračuna svoj javni ključ kot
$$
I_L = \left( \prod_{i=1}^{L-1} I_i \right)^{-1} \cdot g^s \pmod p.
$$
To mu omogoča, da se podpisuje v imenu celotne podskupine $S$, saj se bodo pri množenju v
enačbi~\ref{eq:naive-ver} za preverjanje tako izničil vsi ostali javni ključi.

Za rešitev tega problema se lahko zanesemo na dokaze o znanju brez razkritja znanja.
Torej, da preprečimo napad na generiranje ključev, od vsakega podpisnika $P_i$ zahtevamo, da poleg
svojega javnega ključa $I_i$ objavi tudi dokaz o znanju brez razkritja znanja za svoj zasebni ključ
glede na javni ključ. Objaviti mora torej dokaz, da pozna diskretni logaritem $I_i$ modulo $g$.
Ta dokaz je neinteraktiven, saj obravnavmo model slučajnega oraklja in lahko uporabimo Fiat-Shamirjevo
hevristiko~\ref{sec:fiat-shamir}.

Ker tovrstni dokazi brez preverjevalca nimajo smisla, se na tej točki vredno vprašati, kdo bo preverjal
veljavnost dokazov. Izkaže se, da je najbolj enostavno, da se dokaze doda v posamezne javne ključe.
Tako pade breme preverjanja na tistega, ki bo preverjal podpis. Problematično je dejstvo, da taka
sprememba podaljša javne ključe in privede do izgube učinkovitosti. Preverjanje veljavnosti podpisa 
bo sedaj poleg dveh modularnih potenciranj, ki sta v enačbi~\ref{eq:schnorr-ver} potrebni za
preverjanje standarnega Schnorrovega podpisa, potrebovalo še dodatnih $2|S|$, saj je potrebno
preveriti vse dokaze javnih ključev, kar ustreza preverjanju $|S|$ Schnorrovih podpisov. Posamezni
preverjevalec podpisov lahko sicer dodatno delo opravi le enkrat za vsako skupino, če natančno beleži
rezultate preverjanja dokazov.

\subsubsection{Učinkovitost podpisovanja: Merklova drevesa}
Kot bomo videli, je za dokaz varnosti potrebno, da lahko simulator (torej algoritem, ki bo simuliral
proces podpisovanja napadalcu), v polinomskem času za vsakega pokvarjenega podpisnika $P_j$ pridobi
diskretni logaritem $I_j$ iz predloženega dokaza o znanju brez razkritja znanja. Izkaže pa se, da če
bo $P_j$ dokaz izračunal s $q$ klici slučajnega oraklja, potem bo simulator uspešno pridobil diskretni
logaritem z verjetnostjo največ $1/q$. Še več, če je $b$ pokvarjenih podpisnikov, bo simulator
uspešen z verjetnostjo največ $1/q^b$. Z drugimi besedami, če želimo polinomski simulator, je
podpisnikov lahko največ logaritemsko mnogo v številu klicev oraklja $q$, ker pa je teh klicev
lahko največ polinomsko mnogo v varnostnem parametru $k$, je torej število podpisnikov lahko
največ logaritemsko v $k$.

Ta problem lahko rešimo tako, da vsak podpisnik $P_i$ najprej izračuna svoj par ključev $(s_i, I_i)$
in na podlagi naključno izbrane vrednosti $r_i$ tudi zavezo $X_i = g^{r_i} \pmod p$, ki bi jo uporabil
pri dokazu znanja brez razkritja znanja. Potem si vsi podpisniki izmenjajo javne ključe $I_i$ in
zaveze $X_i$. Vsak podpisnik lahko sedaj izračuna \textit{skupni izziv}
$$
e = H(X_1 || I_1 || X_2 || I_2 || \dots || X_L || I_L).
$$
Podpisniki nato dokončajo svoj dokaz na podlagi zgostitve $e$ in svojega para ključev.

Kot bomo videli, bo to pomenilo, da za generiranje dokazov $b$ pokvarjenih podpisnikov sedaj rabi le
$bq$ klicev oraklja, torej je polinomski simulator uspešen z verjetnostjo $1/bq$. To omogoča, da je
podpisnikov več kot logaritemsko mnogo. Pojavi pa se drugačen problem z učinkovitostjo, saj mora
sedaj vsak podpisnik v svojem javnem ključu hraniti še Schnorrov podpis sporočila $e$ in pa tudi vse
javne ključe sopodpisnikov in njihove zaveze. Brez teh podatkov namreč dokaz znanja (Schnorrov podpis)
ni preverljiv. To pomeni, da je za katerokoli podskupino $S$ velikost ključa proporcionalna velikosti
celotne skupine $P$. Poleg tega mora sedaj preverjevalec preveriti, da se vsi seznami javnih ključev
ujemajo. V primerjavi z osnovno naivno idejo, kjer je preverjevalec potreboval le $|S|$ navadnih
Schnorrovih javnih ključev, je v tej izvedbi velikost javnega ključa nedopustno velika.

Da nazaj pridobimo učinkovit podpis, se lahko zanesemo na slučajnega oraklja in kriptografsko 
orodje, imenovano \textbf{Merklovo drevo} (angl.\ \textit{Merkle tree}). V osnovi je to 
\textit{binarno drevo}, torej drevo, kjer ima vsako vozlišče največ dva otroka. Ideja je, da v liste 
shranimo zgostitve katerekolih podatkov, pridobljene s pomočjo izbranega slučajnega oraklja ali zgoščevalne 
funkcije. Drevo potem gradimo navzgor tako, da v vsako vozlišče shranimo zgostitev stika zgostitev levega in desnega 
otroka. Tako nadaljujemo do korena. Pomembno je, da je za pridobivanje zgostitev uporabljena zgoščevalna 
funkcija, ki je skoraj brez trčenj ali pa slučajni orakelj. Osnovna 
struktura je prikazana na sliki~\ref{fig:merkle}.
\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[<-, >=stealth', auto, semithick,
   level/.style={sibling distance=60mm/#1}]

  \node [rectangle,draw] {$H(H(H(x_1) || H(x_2)) || H(H(x_3) || H(x_4)))$}
    child {node [rectangle,draw] {$H(H(x_1) || H(x_2))$}
        child {node [rectangle,draw] {$H(x_1)$}
            child {node [rectangle,draw] {$x_1$}}
        }
        child {node [rectangle,draw] {$H(x_2)$}
            child {node [rectangle,draw] {$x_2$}}
        } 
    }
    child {node [rectangle,draw] {$H(H(x_3) || H(x_4))$}
        child {node [rectangle,draw] {$H(x_3)$}
            child {node [rectangle,draw] {$x_3$}}
        } 
        child {node [rectangle,draw] {$H(x_4)$}
            child {node [rectangle,draw] {$x_4$}}
        }
    };
  \end{tikzpicture}
  \caption[Merklovo drevo.]{Primer Merklovega drevesa s štirimi listi. Imamo torej $4$ vhodne podatke
    $x_1, x_2, \dots, x_4$, na vsakem nivoju drevesa se izračuna stik in zgostitev. Ustvarjeno s 
    pomočjo~\cite{SOtikz}.}
  \label{fig:merkle}
\end{figure}

Pomembno je opaziti, da če zgoščevalna funkcija ustvarja zgostitve, dolge $k$ bitov, bodo toliko
dolgi vsi podatki, ki jih hranijo vsa vozlišča drevesa. Za Merklova drevesa je ključno, da je v primeru
varne zgoščevalne funkcije računsko zelo težko spremeniti katerokoli vrednost v drevesu, brez da bi se
spremenila vrednost v korenu. Enako velja za spremembe vhodnih podatkov. Merklova drevesa nam torej
omogočajo, da se zavežemo $L$ vrednostim $x_1, x_2, \dots, x_L$ tako, da enostavno vrnemo en sam
$k$-bitni niz. To storimo tako, da shranimo zgostitve vrednosti $x_1, x_2, \dots, x_L$ v liste drevesa
in izračunamo koren. Vrednostim se zavežemo tako, da preverjevalcu damo vrednost korena. Ko mu kasneje
želimo razkriti vrednosti, mu jih enostavno povemo, on pa lahko z izračunom drevesa preveri, da so
vrednosti prave. Povzeto po~\cite{micali2000csproofs}.

\begin{trditev}[Overjevalna pot~\cite{micali2000csproofs}]
\label{trd:overjevalna_pot}
    Naj bo $A$ zavezovalec, ki se želi zavezati vrednostim $x_1, x_2, \dots, x_L$ preverjevalcu $B$. Če
    se $A$ zaveže tako, da $B$ pove vrednost korena Merklovega drevesa, izračunanega na podlagi
    vrednosti $x_1, x_2, \dots, x_L$, potem lahko dokaže zavezo eni vrednosti $x_i$ ($1 \le i \le L$)
    tako, da preverjevalcu $B$ pove $1 + \lceil \log L \rceil$ vrednosti: $x_i$ in pa \textbf{overjevalno
    pot}, torej vrednosti, shranjene v sestrskih vozliščih vseh vozlišč na poti med vključno $x_i$ in
    korenom (brez korena, ki ga $B$ že pozna).
\end{trditev}

\begin{dokaz}
    Trditev lahko dokažemo z indukcijo na globino Merklovega drevesa $d$. Naj bo $x$ vrednost, za katero
    želimo dokazati zavezo in $w_1, w_2, \dots, w_d$ overjevalna pot.
    \begin{itemize}
        \item $d = 2$: Če je globina drevesa $2$, želimo pokazati, da moramo poleg $x$ povemo samo eno
            dodatno vrednost. Ta vrednost je torej zgostitev $x$-ove sosednje vrednosti $y$. Ko $B$ izračuna
            $H(x || y)$, je to že koren, in lahko vrednost primerja z zabeleženo.
        \item $n \rightarrow n + 1$: Predpostavimo torej, da za globino drevesa $n$ lahko preverimo zavezo s
            podanimi $1 + d$ vrednostmi. To nam omogoča izračuna vrednosti v enem od korenovih otrok v
            drevesu globine $n + 1$, po indukcijski predpostavki. Če poznamo še vrednost drugega otroka, je
            možen izračun korena.
    \end{itemize}
\end{dokaz}

Merklova drevesa lahko sedaj uporabimo, da naredimo večstranski podpis bolj učinkovit. Podpisniki
še vedno predložijo dokaze znanja prek Schnorrovega podpisa, po izmenjavi dokazov pa vsak izračuna
Merklovo drevo z listi $I_1, I_2, \dots, I_L$. To drevo bo torej globine $\log L$. Za svoj javni
ključ potem vsak podpisnik $P_i$ nastavi $I_i$ in overjevalno pot za $I_i$. Ker je ponavadi $I_i$
veliko daljši od dolžine zgostitev, in ker je v overjevalni poti le $\log L$ zgostitev, se ključ
ne podaljša veliko (npr.\, če je $I_i$ dolg $2000$ bitov in so zgostitve $200$-bitne, bo $1000$
podpisnikov ustvarilo ključe, dolge manj od $4000$ bitov, torej manj kot dvakrat daljše).

Ko sedaj preverjevalec preverja podpis sporočila $m$ s strani $S$, lahko za vsakega podpisnika
izračuna vrednost korena Merklovega drevesa in preveri, da se vse ujemajo. Obstoj enega nepokvarjenega
podpisnika tako prisili vse pokvarjene, da uporabljajo prave ključe (ali pa najdejo trk v
zgoščevalni funkciji, kar je izjemno težko). S to spremembo smo tako uspešno ohranili podpise
varne in časovno učinkovite.

\subsection{Definicija večstranskega Schnorrovega podpisa}
\label{sec:def_multi_schnorr}
Sedaj smo pripravili vse potrebno, da podamo natančno definicijo končne sheme.

\subsubsection{Skupni parametri}
Vsi podpisniki se strinjajo o skupnem varnostnem parametru $k$ in sekundarnem varnostnem parametru
$k'$, ki je deterministično izračunan iz $k$ (v praksi zadostuje kar $k' = 100$). Za velikost $L$
skupine podpisnikov $P$ predpostavimo, da je polinomska v $k$.

Shemo obravnavamo v modelu slučajnega oraklja, tako da imajo vsi podpisniki dostop do slučajnega
oraklja $H$. Na dogovorjen način ga uporabijo, da ustvarijo pet neodvisnih orakljev
\begin{align*}
    H_1, H_2: \{0, 1\}^* &\rightarrow \{0, 1\}, \\
    H_3, H_5: \{0, 1\}^* &\rightarrow \{0, 1\}^{k'}, \\
    H_4: \{0, 1\}^* &\rightarrow \{0, 1\}^{2k'}.
\end{align*}
Prav tako predpostavimo, da imajo vsi podpisniki dostop do algoritma $GenPrimes$.

Za lažjo obravnavo si izberemo še enega izmed podpisnikov, in ga označimo z $D$. Ta podpisnik bo
vrnil končni podpis, ne ve pa nobenih dodatnih skrivnosti. $D$ lahko tudi predstavlja vse podpisnike,
a je opis sheme malce lažji, če si izberemo enega -- v tem primeru je on prejemnik vseh sporočil
ostalih podpisnikov, svoje odgovore pa potem oddaja (angl.\ \textit{broadcast}) ostalim podpisnikom.
Če si ne izberemo podpisnika $D$, si podpisniki sporočila pošiljajo v krogu (vsak pošlje svoje sporočilo
desnemu sosedu, ko prejme sporočilo levega, spet pošlje desnemu. Vsak torej pošlje $L$ sporočil, na
koncu imajo vsi vse potrebne podatke za izračune).

Kot že omenjeno, v praksi podpisniki uporabijo dobro poznano grupo in zato ne rabijo generirati
parametrov, kar se pa tiče teoretične obravnave, pa morajo sami generirati parametre $p, q$ in $g$.
Za prva dva uporabijo algoritem $GenPrimes(k)$. Za izvor naključnosti uporabijo zaporedje $H_1(2^k),
H_1(2^k + 1), \dots$, Za generiranje elementa $g$ reda $q$ uporabijo izvor naključnosti
$H_2(2^k), H_2(2^k + 1), \dots$

\subsubsection{Generiranje ključev}
Ko ima vsak podpisnik $P_i$ ($1 \le i \le L$) na voljo skupne parametre, si enakomerno naključno
izbere svoj zasebni ključ $s_i \in [0, q - 1]$ in izračuna
$$ 
I_i = g^{s_i} \bmod p.
$$
Do tu je postopek enak, kot pri naivni verziji. Da preprečimo napad na generiranje ključev, mora
vsak podpisnik na tem mestu izbrati naključen $r_i \in [0, q- 1]$ in izračunati zavezo
$$
X_i = g^{r_i} \bmod p.
$$
Potem si podpisniki med seboj izmenjajo vrednosti $(X_i, I_i)$. Vsak na tem mestu lahko izračuna
\begin{align*}
    e &= H_3(X_1 || I_1 || X_2 || I_2 || \dots || X_L || I_L), \\
    y_i &= e s_i + r_i,
\end{align*}
in pošlje $y_i$ vsem ostalim podpisnikom.

Na tem mestu ima vsak podpisnik $P_i$ na voljo par $(X_j, y_j)$ vseh ostalih podpisnikov ($1 \le j
\le L$). Ta par predstavlja Schnorrov podpis in s tem dokaz znanja brez razkritja znanja zasebnega
ključa $s_j$ glede na javni ključ $I_j$. Ker je izziv $e$ izračunan iz podatkov vseh podpisnikov,
onemogoča naknadne spremembe ključev. 

Vsak podpisnik $P_i$ mora preveriti veljavnost vseh podpisov $(X_j, y_j)$ vseh ostalih podpisnikov
$P_j$ ($1 \le j \le L$). To stori s standardnim izračunom za preverjanje Schnorrovega
podpisa~\eqref{eq:schnorr-ver}:
$$
g^{y_j} \stackrel{?}{\equiv} X_j \cdot I_j^{e} \pmod p.
$$

Ko podpisnik $P_i$ ugotovi, da so vsi podpisi veljavni, lahko izračuna Merklovo drevo, ki ima v
listih po vrsti razporejene $I_1, I_2, \dots, I_L$ in za svojo zgoščevalno funkcijo uporablja $H_4$.
Ko je drevo izračunano, $P_i$ prebere overjevalno pot $\text{pot}_i$ svojega ključa $I_i$ in vrne
javni ključ
$$ 
\text{pk}_i = (p, q, g, I_i, \text{pot}_i).
$$

\subsubsection{Podpisovanje}
Naj bo $S = \{P_{id_1}, P_{id_2}, \dots, P_{id_l}\}$ podskupina velikosti $l$ skupine $P$, ki želi
večstransko podpisati sporočilo $m$. To lahko storijo s tremi krogi komunikacije:
\begin{enumerate}
    \item Vsak podpisnik $P_{id_j} (1 \le j \le l)$ si izbere naključno število $r_j \in [0, q - 1]$ 
        in izračuna zavezo
        $$ 
        X_j = g^{r_j} \bmod p.
        $$
        Zavezo $X_j$ nato pošlje podpisniku $D$.
    \item $D$ izračuna skupno zavezo
        $$ 
        \tilde{X} = (X_1 \cdot X_2 \cdot \cdots \cdot X_l) \bmod p
        $$
        in jo pošlje vsem podpisnikom $P_{id_j} (1 \le j \le l)$.
    \item Vsak podpisnik $P_{id_j} (1 \le j \le l)$ izračuna
        \begin{align*}
            e &= H_5(\tilde{X} || m || S), \\
            y_j &= e s_j + r_j
        \end{align*}
        in pošlje $y_j$ podpisniku $D$.
\end{enumerate}
Na tem mestu ima $D$ vse, kar potrebuje, da dokonča podpis. Najprej izračuna
$$
\tilde{y} = (y_1 + y_2 + \cdots + y_l) \bmod q
$$
in nato vrne končni podpis
$$
\sigma = (\tilde{X}, \tilde{y}).
$$

\subsubsection{Preverjanje}
Preverjanje je podobno naivni verziji, le da je treba dodatno preveriti ustreznost Merklovih
korenov. Če torej preverjevalec želi preveriti veljavnost podpisa $\sigma = (\tilde{X}, \tilde{y})$
sporočila $m$, moramo predpostaviti, da lahko dostopa do vseh javnih ključev $\{\text{pk}_{id_1},
\text{pk}_{id_2}, \dots, \text{pk}_{id_l}\}$ vseh podpisnikov $S = \{P_{id_1}, P_{id_2}, \dots, 
P_{id_l}\}$.

Najprej mora preverjevalec preveriti, da se vseh $l$ izvodov skupnih parametrov $p, q$ in $g$ ujema.
Da dokončno potrdi veljavnost in ustreznost javnih ključev, za vsakega podpisnika $P_{id_j} (1 \le
j \le l)$ s pomočjo njegovega javnega ključa $I_{id_j}$ in overjevalne poti $\text{pot}_{id_j}$
izračuna vrednost v korenu Merklovega drevesa $V_{id_j}$, kot prikazano v trditvi~\ref{trd:overjevalna_pot}.
Ko izračuna vse vrednosti korenov $V_{id_j}$, mora preveriti, da so res enake. 

Ko se preverjevalec prepriča o veljavnosti ključev, postopa podobno kot pri naivni verziji. Najprej
mora izračunati
$$
\tilde{I}_S = (I_{id_1} \cdot I_{id_2} \cdot \cdots \cdot I_{id_l}) \bmod p.
$$
Če si dosledno beleži izračune, lahko preverjevalec ta del preverjanja podpisa opravi le enkrat za
vsako podskupino podpisnikov $S$.

Potem mora preverjevalec izračunati izziv s pomočjo slučajnega oraklja
$$
e = H_5(\tilde{X} || m || S)
$$
in preveriti, če velja
\begin{equation}
\label{eq:asm-check}
g^{\tilde{y}} \stackrel{?}{\equiv} \tilde{X} \tilde{I}_S^e \pmod p.
\end{equation}

Če je torej podpis $\sigma = (\tilde{X}, \tilde{y})$ veljaven podpis sporočila $m$, lahko levo stran
enačbe~\eqref{eq:asm-check} zapišemo kot
\begin{align*}
    g^{\tilde{y}} \bmod p &= g^{(y_1 + y_2 + \cdots + y_l) \bmod q} \bmod p \\
                          &\stackrel{\ref{trd:mod-q}}{=} g^{y_1 + y_2 + \cdots + y_l} \bmod p \\
                          &= g^{e s_1 + r_1 + e s_2 + r_2 + \cdots + e s_l + r_l} \bmod p \\
                          &= g^{r_1 + r_2 + \cdots r_l} g^{e (s_1 + s_2 + \cdots s_l)} \bmod p,
\end{align*}
desno pa po trditvi~\ref{trd:mod-mn-pt}
\begin{align*}
    \tilde{X} \tilde{I}_S^e \bmod p &= ((X_1 \cdot X_2 \cdot \cdots \cdot X_l) \bmod p)
        ((I_{id_1} \cdot I_{id_2} \cdot \cdots \cdot I_{id_l}) \bmod p)^e \bmod p \\
    &=((g^{r_1} \bmod p \cdot g^{r_2} \bmod p \cdot \cdots \cdot g^{r_l} \bmod p) \bmod p) \cdot \\
    &\cdot ((g^{s_1} \bmod p \cdot g^{s_2} \bmod p \cdot \cdots \cdot g^{s_l} \bmod p) \bmod p)^e \bmod p \\
    &\stackrel{\ref{trd:mod-mn-pt}}{=} (g^{r_1} \cdot g^{r_2} \cdot \cdots \cdot g^{r_l}) \bmod p) 
        ((g^{s_1} \cdot g^{s_2} \cdot \cdots \cdot g^{s_l}) \bmod p)^e \bmod p \\
    &\stackrel{\ref{trd:mod-mn-pt}}{=} (g^{r_1} \cdot g^{r_2} \cdot \cdots \cdot g^{r_l}) 
        (g^{s_1} \cdot g^{s_2} \cdot \cdots \cdot g^{s_l})^e \bmod p \\
    &= g^{r_1 + r_2 + \cdots r_l} g^{e (s_1 + s_2 + \cdots s_l)} \bmod p.
\end{align*}
Ker se leva in desna stran ujemata, enačba~\eqref{eq:asm-check} pravilno preveri pravilnost večstranskega
Schnorrovega podpisa.

\subsection{Varnost večstranskega Schnorrovega podpisa}
\label{sec:proof_multi_schnorr}
Dokazati si želimo, da je shema, definirana v zgornjem razdelku~\ref{sec:def_multi_schnorr}, \textit{varna},
torej ustreza pogojem definicije varnosti~\ref{def:asm-varnost}, kjer ima napadalec $F$ sposobnosti,
definirane v~\ref{def:asm-napadalec}. Varnost torej pomeni, da je preprečeno eksistencialno ponarejanje,
zaradi napadalčevega nadzora nad komunikacijskim omrežjem pa si lahko privošči napad z izbranimi sporočili.
Še več, ker se ukvarjamo z večstranskimi podpisi, si napadalec lahko izbere še podskupino, ki bo 
sporočilo podpisovala. Napadalec lahko torej na katerikoli točki od katerekoli podskupine zahteva
podpis kateregakoli izbranega sporočila.

Zaradi kompleksnosti napadalca, dokaz varnosti poteka tako, da najprej dokažemo ekvivalentnost med
šibkejšim napadalcem $F'$ in prvotnim napadalcem $F$, potem pa dokažemo varnost v primeru šibkega
napadalca $F'$.

\subsubsection{Šibek napadalec in šibka varnost}
Za enostavnejšo analizo definiramo \textbf{šibkega napadalca} (ali nasprotnika) (angl.\
\textit{weak adversary}) $F'$. Njegov cilj je enak izvornemu napadalcu $F$. Želi si torej ponarediti podpis
s pomočjo napada z izbranim sporočilom in podskupino. Izbere si lahko podpisnika, in od njega
zahteva podpis izbranega sporočila skupaj z izbrano podskupino $S$. Napadalca se razlikujeta v tem,
da je $F'$ bistveno šibkejši, oz.\ ima manj nadzora nad potekom podpisovanja in komunikacijo med
podpisniki.

\begin{definicija}[Šibek napadalec pri ASM]
\label{def:asm-sibek-napadalec}
    Šibek napadalec $F'$ ima v modelu večstranskega podpisa podskupine z odgovornostjo naslednje
    zmožnosti:
    \begin{itemize}
        \item Preden skupina $P$ generira svoje ključe, izbere podpisnika $P_i$, ki ga bo napadel.
        \item Ko je podpisnik $P_i$ napaden, mora $F'$ zanj priskrbeti vse vhode za algoritme in
            vse vhodna sporočila, ki jih prejme. Prav tako lahko vidi vsa poslana sporočila
            podpisnika. Efektivno pri podpisovanju sodelujeta le $F'$ in $P_i$.
        \item Po generiranju ključev, lahko šibek napadalec $F'$ od podpisnika $P_i$ zahteva podpis
            izbranega sporočila skupaj z izbrano podskupino $S$ (izvede napad z izbranim sporočilom in
            podskupino).
    \end{itemize}
\end{definicija}

Ker mora šibek napadalec za izbranega podpisnika predložiti vse vhode in komunikacijo, lahko vidimo
delovanje šibkega napadalca $F'$ kot delovanje napadalca $F$, ki pokvari vse podpisnike, razen
podpisnika $P_i$. V obeh primerih bo podpisnik $P_i$ v podpisu sodeloval le z napadalcem, ki zanj
nadzoruje celoten potek podpisovanja. To povezavo tipov napadalcev formalno opišemo v
izreku~\ref{izr:šibka-varnost}. Pred dokazom izreka pa moramo, tako kot za napadalca $F$, tudi za
šibkega napadalca definirati, kaj pomeni varnost sheme.

\begin{definicija}[Šibka varnost pri ASM]
    Naj bo $k$ varnostni parameter (ki si ga delijo vsi podpisniki). Naj bo $c > 0$ poljubna konstanta. 
    Naj bo $F'$ šibek napadalec, ki je omejen s polinomskim časom v parametru $k$ in ustreza
    definiciji~\ref{def:asm-sibek-napadalec}. Naj bo $P_i$ podpisnik, ki ga šibek napadalec napada.
    Naj bo $p$ verjetnost, da šibek napadalec $F'$ vrne trojico $(\sigma, m, S)$, za katero velja: 
    \begin{itemize}
        \item $\sigma$ je veljaven večstranski podpis sporočila $m$ s strani skupine $S$.
        \item Podpisnik $P_i$ je v skupini $S$, vendar šibek napadalec $F'$ od njega ni zahteval
            podpisa sporočila $m$ s strani skupine $S$.
    \end{itemize}
    Shemi za večstranske podpise podskupine z odgovornostjo bomo rekli, da je \textbf{šibko varna},
    če je verjetnost $p$ zanemarljiva, oz.\ velja
    $$ 
    p < k^{-c}.
    $$
\end{definicija}

Sedej imamo vse potrebno, da dokažemo ekvivalentnost šibke varnosti in varnosti, in s tem
ekvivalentnost šibkega napadalca in napadalca.

\begin{izrek}
\label{izr:šibka-varnost}
    Naj bo velikost $L$ skupine podpisnikov $P$ polinomsko omejena v varnostnem parametru $k$.
    Potem je večstranski Schnorrov podpis skupine velikosti $L$ iz razdelka~\ref{sec:def_multi_schnorr}
    varen natanko tedaj, ko je šibko varen.
\end{izrek}

\begin{dokaz}
    Ker se definicija varnosti in šibke varnosti razlikuje le v uporabi napadalca $F$ ali šibkega
    napadalca $F'$, je potrebno pokazati le, da sta $F$ in $F'$ ekvivalentna (ob ustrezni velikost
    skupine podpisnikov).

    $(\Rightarrow)$: Predpostavimo, da podpis ni šibko varen. Kot smo že prej smo omenili, je delovanje
    šibkega napadalca $F'$ enako delovanju napadalca $F$, ki pokvari vse podpisnike razen enega.
    Napadalec $F$ ima torej vse zmožnosti, ki jih ima šibek napadalec $F'$. Če podpis ni šibko varen,
    lahko $F$ s simulacijo $F'$, opisano zgoraj, z nezanemarljivo verjetnostjo vrne ponarejen podpis,
    torej shema tudi ni varna.

    $(\Leftarrow)$: Predpostavimo, da podpis ni varen. Obstaja torej napadalec $F$, ki je omejen
    s polinomskim časom v varnostnem parametru $k$ in uspešno izvede napad z izbranim sporočilom in
    podskupino.

    Konstruirajmo šibkega napadalca $F'$: skladno z definicijo si pred generiranjem ključev izbere
    podpisnika $P_i$ ($1 \le i \le L$), ki ga bo napadel. Od tega trenutka naprej pri podpisovanju
    sodelujeta samo podpisnik $P_i$ in šibek napadalec $F'$, ki ima vlogo vseh ostalih podpisnikov.

    Ko napadalec $F$ izvede napad, mora torej šibek napadalec $F'$ simulirati delovanje vseh podpisnikov
    razen $P_i$. Vedenje šibkega napadalca $F'$ je tekom napada odvisno od dejanj napadalca $F$:
    \begin{itemize}
        \item Če se napadalec $F$ odloči pokvariti kateregakoli podpisnika, ki ni $P_i$, mu mora 
            šibek napadalec $F'$ (v vlogi podpisnika) posredovati potrebne zasebne informacije. To
            lahko stori, saj simulira delovanje podpisnika.
        \item Če napadalec $F$ pokvari podpisnika $P_i$, je šibek napadalec pri svojem napadu neuspešen.
        \item Če si napadalec $F$ izbere podpisnika (razen $P_i$) za tarčo napada z izbranim sporočilom
            in podskupino, mora šibek napadalec $F'$ simulirati odziv podpisnika. To ponovno lahko
            stori, saj simulira delovanje podpisnika.
        \item Če napadalec $F$ izbere podpisnika $P_i$ za tarčo napada z izbranim sporočilom in podskupino,
            šibek napadalec $F'$ prejme zahtevek za napad od $F$ in ga posreduje podpisniku $P_i$.
            Ta podpisnik normalno pošlje svoj odgovor napadalcu $F$.
    \end{itemize}

    Ko $F$ konča svoj napad, vrne trojico $(\sigma, m, S)$. Če je to veljaven ponaredek, jo vrne tudi
    šibek napadalec $F'$. Če ponaredek ni veljaven, če $P_i$ ni eden izmed podpisnikov v $S$, ali pa
    če je $P_i$ tekom podpisovanja pokvarjen s strani $F$, je šibek napadalec neuspešen pri svojem napadu.
    Poglejmo si verjetnost, da $F'$ uspe pri svojem napadu:
    \begin{align*}
          &\text{Pr}(\text{$F'$ vrne veljaven ponaredek}) = \\
        = &\text{Pr}(\text{$F$ vrne veljaven ponaredek } \cap \text{ $P_i \in S$ in ni pokvarjen}) \\
        = &\sum_{i=1}^L \text{Pr}(\text{$F'$ izbere $P_i$}) \cdot 
            \text{Pr}(\text{$F$ vrne veljaven ponaredek } \cap \text{ $P_i \in S$ in ni pokvarjen}) \\
        = &\sum_{i=1}^L \frac{1}{L} \cdot 
            \text{Pr}(\text{$P_i \in S$ in ni pokvarjen | $F$ vrne veljaven ponaredek}) \\
          &\cdot \text{Pr}(\text{$F$ vrne veljaven ponaredek}) \\
        \geq &\frac{1}{L} \cdot \text{Pr}(\text{$F$ vrne veljaven ponaredek}),
    \end{align*}
    kjer smo pri prehodu iz tretje v četrto vrstico uporabili osnovno lastnost verjetnosti, ki pravi
    $$
    \text{Pr}(A \cap B) = \text{Pr}(A \text{ }|\text{ } B) \cdot \text{Pr}(B),
    $$
    pri prehodu v zadnjo vrstico pa smo upoštevali, da velja
    \begin{equation}
    \label{eq:geq1}
    \sum_{i=1}^L \text{Pr}(\text{$P_i \in S$ in ni pokvarjen | $F$ vrne veljaven ponaredek}) \geq 1.
    \end{equation}
    Neenačba~\eqref{eq:geq1} drži, saj mora pri uspešnem ponarejanju sodelovati vsaj en nepokvarjen
    podpisnik. Če torej $F$ vrne veljaven ponaredek, bo vsaj ena od verjetnosti v zgornji vsoti enaka $1$.

    Pri ponarejanju je torej $F$ uspešen največ $L$-krat več kot $F'$, kar pomeni, da shema ni šibko
    varna, saj je velikost skupine $L$ polinomsko omejena.
\end{dokaz}

\subsubsection{Dokaz varnosti}
Ker sta napadalec in šibek napadalec ekvivalentna, je dovolj pokazati varnost v primeru šibkega
napadalca, shema pa je potem tudi varna po izreku~\ref{izr:šibka-varnost}.

\begin{izrek}[Varnost večstranskega Schnorrovega podpisa]
    Če drži predpostavka o težavnosti diskretnega logaritma pri ASM~\ref{def:asm_dlp}, je večstranski 
    Schnorrov podpis, definiran v razdelku~\ref{sec:def_multi_schnorr}, varen.
\end{izrek}

Želimo torej pokazati, da če obstaja šibek napadalec, ki je omejen s polinomskim časom v varnostnem
parametru $k$, potem obstaja nek algoritem $A$, imenovan simulator, ki prav tako teče v polinomskem
času, s katerim lahko prekršimo predpostavko o diskretnem logaritmu pri ASM.

Konstruirali bomo algoritem $A$, ki za vhod prejme $p, q, g$ in $I$, in vrne $s \in [0, q - 1]$,
da velja $g^s \equiv I \pmod q$. Ideja je, da $A$ simulira proces podpisovanja, ki ga napada šibek
napadalec $F'$. Cilj algoritma $A$ je, da iz vrnjenega ponarejenega podpisa, pridobljenega ob
uspešnem napadu, razbere diskretni logaritem, ki ga išče. Za doseganje tega cilja mora algoritem $A$
biti sposoben simulirati delovanje vseh aspektov procesa podpisovanja (od slučajnega oraklja do
podpisnika $P_i$, ki ga na začetku izbere šibek napadalec $F'$ za svojo tarčo).

Bolj specifično, med svojim delovanjem šibki napadalec $F'$ opravlja dve vrsti poizvedb pri slučajnem
oraklju. Prva je \textit{zgoščevalna poizvedba}, kjer $F'$ pošlje slučajnemu oraklju nek niz, ta pa
mu odgovori z njegovo zgostitvijo. Algoritem $A$ lahko simulira odgovor na tovrstne poizvedbe z vračanjem
naključnih odgovorov.

Druga vrsta poizvedb je \textit{podpisovalna poizvedba}, kjer šibek napadalec $F'$ podpisniku $P_i$
(ki ga je izbral na začetku) pošlje sporočilo $m$ in skupino $S$, ta pa mu nazaj pošlje zavezo $X_i$.
Potem mora šibek napadalec $F'$ igrati vlogo podpisnika $D$, ki agregira informacije (tekom podpisovanja
zbere individualne zaveze in podpise, vrača pa skupne). Podpisniku $P_i$ pošlje skupno zavezo
$\tilde{X}$, nazaj pa dobi $y_i$. Podpisovalne poizvedbe torej potekajo v dveh krogih in predstavljajo
izvedbo napada z izbranim sporočilom in podskupino nad podpisnikom $P_i$, katerega delovanje mora
uspešno simulirati algoritem $A$.

Za lažjo konstrukcijo algoritma $A$, je smotrno šibkega napadalca $F'$ še dodatno poenostaviti. Naj
$q_{\text{zgoščevalna}}$ označuje največje število zgoščevalnih poizvedb, ki jih opravi $F'$,
$q_{\text{podpisovalna}}$ pa največje število podpisovalnih. Naj $\mathcal{F}$ označuje
\textit{poenostavljenega napadalca}, ki deluje popolnoma enako kot šibek napadalec $F'$, le da pred
drugim krogom podpisovalne poizvedbe $\mathcal{F}$ najprej pošlje zgoščevalno poizvedbo slučajnemu
oraklju $H_5$ z vhodom $(\tilde{X}, m, S)$. Podobno, preden $\mathcal{F}$ vrne ponarejen podpis
$(\tilde{X}, \tilde{y})$ sporočila $m_F$, najprej opravi zgoščevalno poizedbo pri slučajnemu oraklju
$H_5$ z vhodom $(\tilde{X}, m_F, S)$. Tako $\mathcal{F}$ vsaki podpisovalni poizvedbi in ponaredku
dodeli zgostitev.

Dodatno predpostavimo še, da poenostavljen napadalec $\mathcal{F}$ po vsaki zgoščevalni poizvedbi
shrani odgovor, zato vsako zgoščevalno poizvedbo za določen vhod opravi le enkrat. 

Poenostavljen napadalec $\mathcal{F}$ torej opravi $q_{\text{podpisovalna}}$ podpisovalnih poizvedb
in $q_{\text{zgoščevalna}} + q_{\text{podpisovalna}} + 1$ zgoščevalnih poizvedb. Skupno število
klicev oraklja $H_5$ s strani $\mathcal{F}$ označimo $q_H$. Shranjevanje odgovorov na poizvedbe je
računsko zanemarljivo, zato $\mathcal{F}$ opravi toliko dela, kot šibek napadalec $F'$ skupaj s
stroškom poizvedb. Če torej predpostavimo učinkovitost slučajnega oraklja, teče $\mathcal{F}$ v
polinomskem času, saj tudi šibek napadalec $F'$ teče v polinomskem času.

Algoritem $A$ bo za delovanje uporabljal poenostavljenega napadalca $\mathcal{F}$, saj bo tako za
vsak potencialni ponaredek in vsak napad prejel predogled rezultata prek zgostitve, ki jo vrne $H_5$.

Algoritem $A$ mora torej znati odgovoriti na vse poizvedbe poenostavljenega napadalca $\mathcal{F}$.
Na zgoščevalne poizvedbe odgovarja naključno, s pomočjo vnaprej izbranih simuliranih odgovorov $e_1,
e_2, \dots, e_{q_H}$ oraklja $H_5$. Odgovor na podpisovalno poizvedbo za podpisnika $P_i$ na vhodu
$m$ in $S$ je malce bolj zapleten. Algoritem $A$ stori sledeče:
\begin{enumerate}
    \item Shrani konfiguracijo poenostavljenega napadalca $\mathcal{F}$.
    \item \label{rewind} Si izbere naključen odgovor $e_j$ ($1 \le j \le q_H$) oraklja $H_5$, 
        v upanju, da bo to zgostitev, ki bo identificirala to poizvedbo.
    \item Si izbere naključen $y \in [0, q - 1]$.
    \item Izračuna 
        $$
        X_i = I_i^{-e_j}g^y \bmod p
        $$
        in pošlje $X_i$ v odgovor prvega kroga poizvedbe poenostavljenemu napadalcu $\mathcal{F}$.
    \item Po prejetju $\tilde{X}$ od $\mathcal{F}$ preveri, če $e_j$ ustreza poizvedbi na vhodu
        $(\tilde{X}, m, S)$. Če da, vrne $y$, sicer se vrne na korak~\ref{rewind}.
\end{enumerate}
Zgornje je primer splošne metode za analiziranje varnosti v kriptografiji, ki se imenuje 
\textbf{previjanje nazaj} (angl.\ \textit{rewinding}). Popularna je pri analizi dokazov brez razkritja
znanja in pri dokazih varnosti v modelu slučajnega oraklja. Metoda dovoli, da prek naključnih izbir
algoritem odgovori na poizvedbo, preden je postavljena, za ceno največ toliko previjanj, kot ima
poizvedba odgovorov.

\begin{opomba}
    V kontekstu dokaza varnosti je napadalec naključnostni algoritem, omejen s polinomskim časom.
    Simulator (algoritem $A$), ki ga konstruiramo, pa je algoritem, ki tekom svojega delovanja
    uporablja napadalca kot podprogram. To simulatorju omogoča, da pozna celotno interno stanje
    napadalca, vključno z vsemi naključnimi izbirami, ki jih je napadalec opravil. Zato lahko
    simulator shranjuje stanja napadalca, in shranjena stanja uporabi, da ga previje nazaj na
    prejšnje stanje.
\end{opomba}

V tem primeru je previjanje nazaj nujno potrebno za simuliranje iskrenega podpisnika $P_i$. To je zato,
ker poenostavljen napadalec $\mathcal{F}$ igra vlogo vseh ostalih podpisnikov, torej ima odločilno
vlogo pri izbiri skupne zaveze $\tilde{X}$. Na podlagi te zaveze je izračunan skupni izziv 
$e = H_5(\tilde{X} || m || S)$, ki ga $P_i$ uporabi za izračun $y_i$. 

Ko algoritem $A$ simulira podpisni proces za poenostavljenega napadalca $\mathcal{F}$, mora torej
$A$ izračunati zavezo $X_i$ in jo poslati v prvem krogu poizvedbe (namesto podpisnika $P_i$). Problem
je, da na tej točki še ni znan izziv $e$. Za uspešno simulacijo mora algoritem $A$ uganiti, kateri
odgovor oraklja $H_5$ bo ustrezal vhodu. Ker je možnih odgovorov oraklja $q_H$ in je vsaka enako
verjetna, je verjetnost, da algoritem $A$ izbere pravilen odgovor, $1/q_H$. Pričakovano število
potrebnih previjanj je torej $q_H$.

Sedaj lahko konstruiramo algoritem $A$ na podlagi poenostavljenega napadalca $\mathcal{F}$. $A$ torej
prejme instanco problema diskretnega logaritma s podatki $p, q, g$ in $I$ (kot predstavljeno v 
definiciji~\ref{def:asm_dlp}). Podpisnika, ki ga poenostavljen napadalec napada, označimo $P_i$
(to je torej edini nepokvarjeni podpisnik, v njegovo vlogo se mora postaviti algoritem $A$).

Algoritem $A$ mora najprej doseči, da so parametri $p, q$ in $g$ iz predloženega problema diskretnega
logaritma točno deljeni javni parametri pri večstranskem Schnorrovem podpisu. To doseže prek
manipulacije izvora naključnosti za generiranje parametrov, torej orakljev $H_1$ in $H_2$. Ker
algoritem $A$ simulira delovanje vseh slučajnih orakljev, lahko nastavi $H_1$ in $H_2$ tako, da
bodo rezultati algoritma za generiranje ključev točno $p, q$ in $g$. Za konec nastavi še javni
ključ $I_i$ podpisnika $P_i$ na $I$.

Naslednji korak je dokaz znanja diskretnega logaritma $g^s \equiv I \pmod q$. Ta diskretni logaritem
je točno ta, ki ga algoritem $A$ išče, torej ga na tem mestu še ne pozna. Dokaz znanja lahko zaobidemo
na podoben način, kot pri odgovarjanju na podpisovalne poizvedbe. V jedru problema je ponovno dejstvo,
da mora $A$ poslati zavezo $X_i$, preden pozna izziv $e$. Algoritem $A$ mora torej ponovno uganiti
pravilen odgovor, tokrat oraklja $H_3$. Ponovno to lahko doseže s postopkom previjanja poenostavljenega
napadalca $\mathcal{F}$. Če označimo število poizvedb, ki jih $\mathcal{F}$ pošlje oraklju $H_3$ s
$q_{H_3}$, lahko izračunamo, da je pričakovano število previjanj, ki jih opravi algoritem $A$,
enako $q_{H_3}$.

Na tem mestu je vse pripravljeno, da lahko algoritem $A$ začne simulirati postopek podpisovanja in
požene poenostavljenega napadalca $\mathcal{F}$ ter odgovarja na njegove poizvedbe kot opisano zgoraj.
Ideja dokaza od tu naprej je, da ko poenostavljen napadalec $\mathcal{F}$ vrne ponarejen podpis,
algoritem $A$ uporabi previjanje in \textbf{lemo o razcepu}~\ref{izr:forking} (angl.\
\textit{forking lemma}), da pridobi še en ponarejen podpis. Iz teh dveh ponaredkov potem lahko
izlušči odgovor na dani problem diskretnega logaritma.

\begin{izrek}[Lema o razcepu~\cite{pointcheval1996forking}]
\label{izr:forking}
    Naj bo $\mathcal{S}$ podpisna shema, ki vrača dvodelne podpise $\sigma = (\sigma_1, \sigma_2)$,
    kjer $\sigma_2$ temelji na zgostitvi vhodnega sporočila $m$ in $\sigma_1$ (npr.\ pri Schnorrovem 
    podpisu je ta zgostitev izziv  $e = H(X || m)$). Naj slučajni orakelj $H$ vrača zgostitve
    dolžine $n$. Varnostni parameter naj bo $k$, tako da velja $n \gg \log(k)$.

    Naj bo $F$ naključnostni polinomski algoritem, ki ima na voljo vse javne podatke pri podpisni
    shemi $\mathcal{S}$ in dostop do oraklja $H$. Če lahko $F$ z nezanemarljivo verjetnostjo vrne par
    $(m, \sigma)$, kjer je $\sigma$  veljaven podpis sporočila $m$, potem lahko z nezanemarljivo
    verjetnostjo z enakimi vhodnimi podatki in uporabo drugega oraklja, $F$ vrne dva para
    $(m, \sigma)$ in $(m. \sigma')$, kjer podpisa temeljita na drugačnih zgostitvah.
\end{izrek}

Pred dokazom leme o razcepu, moramo najprej pokazati enostavnejšo lemo iz verjetnosti.

\begin{lema}
\label{lema:verjetnost}
    Naj bosta $X$ in $Y$ množici. Naj bo $0 < \epsilon < 1$ in $A$ podmnožica $X \times Y$. Naj bo
    par $(x, y)$ naključno izbran iz poljubne verjetnostne porazdelitve nad $X \times Y$, tako da
    velja
    $$
    \text{Pr}((x, y) \in A) \geq \epsilon.
    $$

    Potem obstaja podmnožica $\Omega \subset X$, tako da
    \begin{itemize}
        \item $\text{Pr}(x \in \Omega) > \epsilon / 2$ in
        \item za vsak $a$ iz $\Omega$ velja, da $\text{Pr}((a, y) \in A) \geq \epsilon / 2$.
    \end{itemize}
\end{lema}

\begin{dokaz}
    Za vsak $x$ iz $X$ definirajmo
    $$
    p(x) = \text{Pr}((x, y) \in A \text{ }|\text{ } x).
    $$
    Zakon o popolni verjetnosti nam pove, da velja
    $$
    \text{Pr}((x, y) \in A) = \sum_{x \in X} \text{Pr}(x) \cdot p(x) = \text{E}[p(x)].
    $$
    Ker je po predpostavki velja $\text{Pr}((x, y) \in A) \geq \epsilon$, velja tudi
    $$
    \text{E}[p(x)] \geq \epsilon.
    $$

    Definirajmo množico $\Omega$ kot
    $$
    \Omega = \{x \in X \text{ }|\text{ p}(x) \geq \epsilon / 2\}.
    $$
    Neposredno iz definicije množice sledi drugi del leme: če je $a$ v $\Omega$, mora zanj veljati
    $$
    p(a) = \text{Pr}((a, y) \in A \text{ }|\text{ } a) \geq \epsilon / 2.
    $$

    Za prvi del leme pa najprej predpostavimo obratno, da je $\text{Pr}(x \in \Omega) \leq \epsilon / 2$.
    Ker za $x$, ki ni v $\Omega$ velja $p(x) < \epsilon / 2$ (zunaj $\Omega$ je $p(x)$ strogo manjši
    od $\epsilon / 2$), lahko pričakovano vrednost ocenimo kot
    \begin{align*}
        \text{E}[p(x)] &= \text{E}[p(x) \mathbb{I}_{x \in \Omega}] + \text{E}[p(x) \mathbb{I}_{x \notin \Omega}]. \\
                       &\leq 1 \cdot \text{Pr}(x \in \Omega) + \frac{\epsilon}{2} \cdot \text{Pr}(x \notin \Omega) \\
                       &= \text{Pr}(x \in \Omega) + \frac{\epsilon}{2} \cdot (1 - \text{Pr}(x \in \Omega)) \\
                       &\leq \frac{\epsilon}{2} + \frac{\epsilon}{2} \cdot \left(1 - \frac{\epsilon}{2}\right) \\
                       &= \epsilon - \frac{\epsilon^2}{4} \\
                       &< \epsilon.
    \end{align*}
    To je v nasprotju z našo predpostavko, da velja $\text{E}[p(x)] \geq \epsilon$. Tako smo pokazali,
    da mora veljati $\text{Pr}(x \in \Omega) > \epsilon / 2$, s čimer smo dokazali prvi del leme.
\end{dokaz}

Sedaj imamo vse potrebno, da dokažemo lemo o razcepu.

\begin{dokaz}[Dokaz leme o razcepu~\ref{izr:forking}]
    Naj bo $F$ napadalec (naključnostni algoritem, ki teče v polinomskem času), ki nima na voljo
    nobenega sporočila. Z $\omega$ označimo vir naključnih bitov, do katerega ima $F$ dostop. Denimo,
    da med svojim napadom napadalec $F$ slučajnemu oraklju $H$ pošlje največ polinomsko mnogo poizvedb
    v varnostnem parametru $k$. Označimo  poizvedbe, ki jih $F$ stori z $\mathcal{Q}_1, \mathcal{Q}_2,
    \dots, \mathcal{Q}_Q$ (brez škode za splošnost lahko predpostavimo, da so poizvedbe med seboj
    različne). Pripadajoče odgovore oraklja na poizvedbe označimo z $\rho_1, \rho_2 , \dots, \rho_Q$.

    Predpostavimo, da lahko za naključno izbran vir bitov $\omega$ in naključno izbran orakelj $H$,
    napadalec $F$ z nezanemarljivo verjetnostjo vrne par $(m, \sigma)$, kjer je $\sigma$ veljaven podpis
    sporočila $m$. Verjetnost tu jemljemo nad vsemi viri bitov $\omega$ in nad vsemi orakljevimi
    odgovori $\rho_1, \rho_2, \dots, \rho_Q$. To verjetnost označimo z $\text{Pr}_{\omega, \rho_1,
    \rho_2 , \dots, \rho_Q}$. 

    Ker so odgovori oraklja izbrani iz naključne funkcije, je verjetnost, da je bila ena izmed
    poizvedb oraklju prav tista, ki je vsebovala sporočilo $m$ in delni podpis $\sigma_1$,
    nezanemarljiva. Sicer bi moral napadalec $F$ uganiti odgovor na to poizvedbo, da bi
    lahko ustvaril drugi del podpisa $\sigma_2$ (uganiti bi torej moral naključno vrednost, kar lahko
    stori z največ zanemarljivo verjetnostjo). Označimo poizvedbo s temi podatki $\mathcal{Q}_\beta
    = (m, \sigma_1)$ ($1 < \beta < Q$). Ker je poizvedb polinomsko mnogo v varnostnem parametru $k$
    in je verjetnost uspeha nezanemarljiva, morata obstajati polinom $P(k)$ in število $\beta$, za
    katera je verjetnost uspeha
    $$
    \text{Pr}_{\omega, \rho_1, \rho_2 , \dots, \rho_Q}(\text{$F$ vrne veljaven ponaredek in } \mathcal{Q}_\beta
    = (m, \sigma_1)) \geq \frac{1}{P(k)},
    $$
    kjer je poizvedba $\mathcal{Q}_\beta$ res temeljila na sporočilu in delnem podpisu, slučajnost
    pa izvira iz vira bitov $\omega$ in orakljevih odgovorov $\rho_1, \rho_2, \dots, \rho_Q$.

    Če označimo z $\Omega$ množico vseh naključnih virov bitov $\omega$ in z $R$ množico vseh
    zaporedij $\rho_1, \rho_2, \dots, \rho_Q$ orakljevih odgovorov, lahko uporabimo lemo~\ref{lema:verjetnost},
    kjer je $X = \Omega$, $Y = R$, $A$ je dogodek, da je $F$ uspešen in $\epsilon = 1/P(k)$.
    Lema nam zagotavlja obstoj množice $\Omega_\beta$, ki vsebuje vse vire bitov $\omega$, za katere
    velja, da je verjetnost uspeha po orakljevih odgovorih $\rho_1, \dots, \rho_Q$ navzdol omejena z
    $1/2P(k)$, oz.,\ da za vir bitov $\omega$ iz množice $\Omega_\beta$ velja
    $$
    \text{Pr}_{\rho_1, \rho_2, \dots, \rho_Q}(\text{$F$ vrne veljaven ponaredek in } \mathcal{Q}_\beta
    = (m, \sigma_1)) \geq \frac{1}{2P(k)}.
    $$

    Sedaj lahko poleg $\beta$ fiksiramo še vir bitov $\omega$ iz množice $\Omega_\beta$. To nam da
    deterministično zaporedje poizvedb $Q_1, Q_2, \dots, Q_Q$, kjer velja $\mathcal{Q}_\beta =
    (m, \sigma_1)$, napadalec pa uspe z nezanemaljivo verjetnostjo. Na tem mestu lahko ponovno
    uporabimo lemo~\ref{lema:verjetnost}, kjer je $X$ množica odgovoro na prvih $\beta - 1$ poizvedb,
    $Y$ množica odgovorov na preostalih $Q - \beta + 1$ poizvedb, $A$ je dogodek, da je $F$ uspešen
    in $\epsilon = 1/2P(k)$. To nam zagotavlja obstoj množice $R_{\beta, \omega}$, ki vsebuje vsa
    zaporedja $(\rho_1, \dots, \rho_{\beta - 1})$, za katera velja, da je verjetnost uspeha po
    preostanku odgovorov $(\rho_\beta, \dots, \rho_Q)$ večja od $1/4P(k)$. To pomeni, da za
    zaporedje $(\rho_1, \dots, \rho_{\beta - 1})$ iz množice $R_{\beta, \omega}$, velja
    $$
    \text{Pr}_{\rho_\beta, \dots, \rho_Q}(\text{$F$ vrne veljaven ponaredek in } \mathcal{Q}_\beta
    = (m, \sigma_1)) \geq \frac{1}{4P(k)}.
    $$

    Množici $\Omega_\beta$ in $R_{\beta, \omega}$ določata možne $\beta, \omega$ in $(\rho_1, \dots,
    \rho_{\beta - 1})$, za katere si lahko izberemo dve množici odgovorov $(\rho_\beta, \dots, \rho_Q)$
    in $(\rho_\beta', \dots, \rho_Q')$, za kateri napadalec $F$ z nezanemarljivo verjetnostjo vrne
    dva para $(m, \sigma)$ in $(m, \sigma')$, kjer sta $\sigma$ in $\sigma'$ veljavna podpisa sporočila
    $m$, ki temeljita na drugačnih zgostitvah. Tu smo uporabili pogoj $n \gg \log(k)$ oz.,\ da je
    dolžina orakljevih odgovorov $n$ veliko večja od varnostnega parametra $k$. Ta pogoj nam zagotavlja,
    da je veliko različnih oraljevih odgovorov, oz.\ da je verjetnost, da se zgodi trčenje,
    zanemarljiva.

    Torej, z naključno izbiro $\beta$, $\omega$, $(\rho_1, \dots, \rho_{\beta - 1}), (\rho_\beta, 
    \dots, \rho_Q)$ in $(\rho_\beta', \dots, \rho_Q')$ lahko z nezanemarljivo verjetnostjo dobimo
    dva veljavna podpisa $\sigma$ in $\sigma'$ sporočila $m$, ki temeljita na drugačnih zgostitvah.
\end{dokaz}

Vrnimo se na dokaz varnosti večstranskega Schnorrovega podpisa. Ostali smo pri algoritmu $A$, ki
tekom svojega delovanja poganja poenostavljenega napadalca $\mathcal{F}$. 

Denimo, da $\mathcal{F}$ vrne ponarejen podpis $(\tilde{X}_0, \tilde{y}_0)$ sporočila $m_0$ s strani
podskupine $S_0$. Še več, ponaredek je nastal na podlagi $j_0$-te poizvedbe oraklju $H_5$ z vhodom
$(\tilde{X}_0, m_0, S_0)$ in odgovorom $e_{j_0}$. Ker $A$ pozna celotno notranje stanje poenostavljenega
napadalca $\mathcal{F}$ in si je shranjeval njegova interna stanja, lahko simulator $A$ previje
poenostavljenega napadalca $\mathcal{F}$ nazaj na začetek podpisovnja z enakim virom naključnih bitov
$\omega$. Na njegove poizvedbe odgovarja enako kot prej, le na $j_0$-to poizvedbo odgovori z novo
naključno vrednostjo $e_{j_0}'$. Delovanje napadalca $\mathcal{F}$ pred previjanjem imenujemo prvi
pogon, delovanje po previjanju pa drugi pogon.

Ker so podpisovalne poizvedbe razdeljene na dva kroga in temeljijo na zgoščevalnih poizvedbah (za
pridobitev izziva $e$), se lahko zgodi, da je $j_0$-ta zgoščevalna poizvedba opravljena sredi ene
od podpisovalnih. Označimo z $r$ število podpisovalnih poizvedb v prvem pogonu, katerih prvi krog
poenostavljen napadalec $\mathcal{F}$ opravi pred $j_0$-to zgoščevalno poizvedbo. Ker mora legitimen
ponarejen podpis podpisovati sporočilo s strani skupine, ki tega sporočila še ni podpisala, lahko
sklepamo, da nobena od podpisovalnih poizvedb v prvem pogonu ni temeljila na $j_0$-ti zgoščevalni
poizvedbi.

Ker je pri drugem pogonu uporabljen enak vir naključnih bitov $\omega$ in so odgovori na poizvedbe do
$j_0$-te enaki, nobena od prvih $r - 1$ podpisovalnih poizvedb v drugem pogonu ni temeljila na $j_0$-ti
zgoščevalni. V drugem pogonu napadalca lahko algoritem $A$ torej vrne shranjene odgovore na prvih
$r - 1$ podpisovalnih poizvedb, kar med drugim pomeni, da za te poizvedbe ni potrebno previjanje
nazaj. To pa je lahko potrebno pri $r$-ti podpisovalni poizvedbi, saj se drugi krog lahko zgodi po
$j_0$-ti podpisovalni poizvedbi. Verjetnost previjanja je $1 - 1/q_H$, kjer je $1/q_H$ verjetnost,
da je drugi krog $r$-te podpisovalne poizvedbe izveden na podlagi enake zgoščevalne poizvedbe, kot
pri prvem pogonu.

\begin{opomba}
    V dejstvo, da nobena od prvih $r - 1$ podpisovalnih poizvedb v drugem pogonu ni temeljila na
    $j_0$-ti zgoščevalni poizvedbi, temelji na predpostavki, da ne dovoljujemo hkratnih podpisovalnih
    poizvedb, ki je standardna pri dokazih z lemo o razcepu.
\end{opomba}

Če previjanje pri $r$-ti podpisovalni poizvedbi ni potrebno, potem so pogoji pri $j_0$-ti zgoščevalni
poizvedbi popolnoma enaki, kot pri prvem pogonu (enak vir naključnih bitov napadalca in enake
zgoščevalne poizvedbe). Od tu lahko zaključimo, da bo tudi $j_0$-ta poizdveba imela enak vhod:
$(\tilde{X}_0, m_0, S_0)$, odgovor pa bo seveda drugačen. Če tudi v tem pogonu poenostavljen napadalec
$\mathcal{F}$ uspešno vrne ponaredek $(\tilde{X}_1, \tilde{y}_1)$ podpisa sporočila $m_1$ s strani
podskupine $S_1$, ki temelji na poizvebi $j_0$, potem smo lahko prepričani, da velja $m_1 = m_0,
S_1 = S_0$ in $\tilde{X}_1, = \tilde{X}_0$.

Ključno, enačbi za preverjanje podpisov potem lahko zapišemo kot
\begin{align*}
    g^{\tilde{y}_0} &\equiv \tilde{X}_0 \tilde{I}_{S_0}^{e_{j_0}} \pmod p, \\
    g^{\tilde{y}_1} &\equiv \tilde{X}_1 \tilde{I}_{S_1}^{e_{j_0}'}
        \equiv \tilde{X}_0 \tilde{I}_{S_0}^{e_{j_0}'} \pmod p.
\end{align*}
Opazimo, da lahko izrazimo $\tilde{X}_0$ na dva načina, ki ju enačimo:
$$
\tilde{X}_0 \equiv g^{\tilde{y}_0}(\tilde{I}_{S_0}^{e_{j_0}})^{-1}
    \equiv g^{\tilde{y}_1}(\tilde{I}_{S_0}^{e_{j_0}'})^{-1} \pmod p.
$$
Če premečemo dobljeno enačbo, dobimo
$$
\tilde{I}_{S_0}^{- e_{j_0}'} \tilde{I}_{S_0}^{e_{j_0}} \equiv g^{\tilde{y}_0}(g^{\tilde{y}_1})^{-1} \pmod p,
$$
kar nam omogoča izraziti $\tilde{I}_{S_0}$ kot
$$
\tilde{I}_{S_0} \equiv g^{(\tilde{y}_0 - \tilde{y}_1) (e_{j_0} - e_{j_0}')^{-1}} \pmod p.
$$
To torej pomeni, da $A$ lahko izračuna diskretni logaritem $\tilde{I}_{S_0}$ kot 
$(\tilde{y}_0 - \tilde{y}_1) (e_{j_0} - e_{j_0}')^{-1}$. Še vedno pa nismo pri koncu, saj to ni
diskretni logaritem, ki nas zanima. Če podpisnike iz $S_0$ označimo $S_0 = \{P_{i_1}, \dots, P_{i_l}\}$,
potem je 
$$
\tilde{I}_{S_0} = \prod_{j=1}^l I_{i_j},
$$
kjer je vrednost, katere diskretni logaritem želimo izračunati, $I_i$, nujno ena izmed $I_{i_j}$,
saj mora podpisnik $P_i$ biti del skupine $S_0$, če želimo, da je ponaredek veljaven. $A$ mora sedaj
pridobiti diskretne logaritme vseh ostalih $I_{i_j}$ in jih odšteti iz diskretnega logaritma
$\tilde{I}_{S_0}$. Tu uporabimo dejstvo, da mora $P_i$ med generiranjem ključev pridobiti in preveriti
dokaze znanja brez razkritja znanja o diskretnih logaritmih vseh $I_{i_j}$, razen za $i_j = i$.
Spomnimo se, da poenostavljen napadalec $\mathcal{F}$ deluje tako, da si izbere tarčo (podpisnika $P_i$)
in se nato postavi v vlogo vseh ostalih podpisnikov. To pomeni, da mora dokaze znanja generirati
prav napadalec $\mathcal{F}$ (ki torej pozna vrednosti $s_{i_j}$).

Ker so dokazi znanja brez razkritja znanja o diskretnih logaritmih samo Schnorrovi podpisi, lahko
uporabimo lemo o razcepu~\ref{izr:forking}, prek katere algoritem $A$ lahko previje napadalca
$\mathcal{F}$ in prejme diskretni logaritem $s_{i_j}$, katerega znanje dokazuje $\mathcal{F}$.
Ker vsi podpisniki za dokaz uporabijo enak izziv $H_3(X_1, I_1, \dots, X_L, I_L)$, se
mora zgoditi samo en razcep, na podlagi katerega lahko algoritem $A$ izračuna vse diskretne
logaritme $s_{i_j}$.

Vprašanje, ki ostane, je časovna zahtevnost algoritma $A$. Standardne operacije podpisovanja
so polinomske v varnostnem parametru $k$, zato so polinomske tudi za $A$. Prav tako so učinkoviti
odgovori na zgoščevalne poizvedbe. Najbolj časovno zahteven del so previjanja, ki jih je lahko $q_H$
za vsak podpis in generiranje ključev. Ker je poenostavljen napadalec $\mathcal{F}$ polinomski algoritem,
lahko opravi največ polinomsko poizvedb, torej je $q_H$ polinomsko število v $k$. Časovna zahtevnost
algoritma $A$ pa je proporcionalna $q_H$, torej tudi polinomska v $k$.

Verjetnost uspeha algoritma $A$ temelji na verjetnosti uspeha poenostavljenega napadalca $\mathcal{F}$.
Ta verjetnost je pomnožena še s faktorjem, ki je obratno sorazmeren polinomu v $q_H$. Ker smo
začeli z nezanemarljivo verjetnostjo, in jo skalirali samo s polinomskimi faktorji, je verjetnost
uspeha algoritma $A$ še vedno nezanemarljiva. $A$ je torej res polinomski algoritem, ki z
nezanemarljivo verjetnostjo vrne odgovor na problem diskretnega algoritma. Ker predpostavljamo, da
tak algoritem ne obstaja, je večstranski Schnorrov podpis varen.

\section{Primerjava navadnega in večstranskega Schnorrovega podpisa}
\label{sec:primerjava}
Naravno vprašanje, ki se pojavi ob omembi večstranskega Schnorrovega podpisa podskupine z odgovornostjo,
je, kakšne prednosti ponuja pred uporabo večih navadnih Schnorrovih podpisov. Najočitnejša prednost
je, da skupinski podpis vrne en sam podpis, ki je primerljivo dolg s Schnorrovim, medtem ko uporaba
individualnih podpisov pomeni, da mora preverjevalec preveriti toliko podpisov, kot je velika
skupina. To prednost večstranskega podpisa je posebej pomembna v primerih, ko je preverjevalčev čas
zelo omejen ali drag. Odličen primer je pri vseh aplikacijah, ki temeljijo na veriženju blokov, kjer
preverjanje podpisov poteka ">na verigi"<, torej je za vsako operacijo potrebno plačati.

Seveda pa je potrebno omeniti tudi slabosti večstranskega podpisa v primerjavi z navadnim. Najbolj
očitna je, da morajo podpisniki med seboj komunicirati, kar lahko pomeni velike izgube časa. Uporabna
vrednost večstranskih podpisov torej sloni na primerih, kjer je komunikacija enostavna, čas in
računska moč preverjevalca pa izjemno dragocena (ponovno so odličen primer aplikacije, ki slonijo
na veriženju blokov).

\subsection{Empirična analiza}
Za empirično potrditev zgornjih trditev smo naredili program, ki implementira oba podpisa v nekoliko
poenostavljenem okolju. Zanemarili smo čas komunikacije pri obeh verzijah podpisov, saj je to nezanesljiv
podatek, ki je odvisen od okolja. Cilj primerjave je videti, kako se razlikuje čas izvedbe posameznih
komponent podpisov pri različnem številu podpisnikov.

Podpisa smo implementirali v programskem jeziku Go, vsa izvorna koda je na voljo na
\href{https://github.com/timkalan/magisterij}{https://github.com/timkalan/magisterij}. Poskusi so
bili izvedeni na računalniku z Apple M1 Pro procesorjem in 16 GB RAM-a. Vsak poskus smo ponovili
šestkrat, da smo dobili stabilne rezultate, ki smo jih nato povprečili. Za dodatno nazornost, smo
izračunali še standardne odklone vseh poskusov. Vsi grafi prikazujejo povprečne vrednosti skupaj s
standardnim odklonom.

Poskusi so bili narejeni z $1, 2, 5, 10, 20, 30, \dots, 200$ podpisniki. Velikost parametra $q$, ki
določa grupo iz katere je generator, je bila $256$ bitov. Za zgoščevalno funkcijo smo uporabili
\texttt{SHA-256}, ki je bila izbrana zaradi velike razširjenosti.

\subsubsection{Generiranje ključev}
Generiranje ključev se pri obeh podpisih začne enako. Vsi podpisniki morajo izbrati naključne zasebne
ključe in generirati javne ključe kot $X_i = g^{s_i} \pmod p$. Tu se generiranje ključev za navaden
Schnorrov podpis konča, pri večstranskem podpisu pa je potrebno še ustvariti dokaze znanja brez
razkritja znanja, jih poslati vsem ostalim podpisnikom in preveriti njihovo veljavnost. To je seveda
zelo veliko dodatnega dela, ki pa ga je za določeno skupino potrebno opraviti samo enkrat (kot je
tudi potrebno samo enkrat generirati par ključev pri navadnem Schnorrovem podpisu).

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\textwidth]{images/benchmark_KeyGeneration.pdf}
  \caption[Generiranje ključev.]{Primerjava časov generiranja ključev pri navadnem in večstranskem
    Schnorrovem podpisu. Prikazan je skupen čas generiranja ključev za vse podpisnike.}
  \label{fig:generiranje}
\end{figure}

Kot je razvidno iz slike~\ref{fig:generiranje}, je čas generiranja ključev pri večstranskem podpisu
mnogo daljši, ne glede na količino podpisnikov. Rast zahtevnosti v obeh primerih je linearna
s številom podpisnikov, a je vseeno hitrejša pri večstranskem podpisu. V praksi je za večstranski
podpis potrebno še več časa, saj smo tu zanemarili čas komunikacije, ki je v tem primeru linearen
s številom podpisnikov. Ker pa se mora ta komunikacija zgoditi samo enkrat, jo tu zanemarimo (ključe
skupina ustvari le ob začetku sodelovanja). Za predstavo razlike, pri $100$ podpisnikih se za
generiranje ključev pri navadnem podpisu porabita približno $2$ milisekundi, pri večstranskem pa
$8$ milisekund, torej štirikrat več.

Generiranje ključev predstavlja veliko prednost za uporabo navadnega Schnorrovega podpisa, vendar
si moramo zapomniti, da je to postopek, ki ga mora skupina opraviti le enkrat, hkrati pa ne obremenjuje
preverjevalca. Če smo torej v situaciji, kjer mora ista skupina podpisnikov velikokrat podpisati
sporočila, je čas generiranje ključev zanemarljiv, v primeru enkratnih skupin pa je morda smiselno
razmišljati o uporabi navadnega Schnorrovga podpisa.

\subsubsection{Podpisovanje}
Pri podpisovanju največjo razliko med podpisoma naredi potreba po komunikaciji med podpisniki pri
večstranskem podpisu. Zahtevno je predvem to, da so za ustvarjanje enega podpisa potrebni trije
krogi komunikacije: 
\begin{itemize}
    \item izmenjava zavez $X_i$,
    \item izmenjava skupne zaveze $\tilde{X}$
    \item in izmenjava izziva $e$.
\end{itemize}
Če pa komunikacijo zanemarimo, pa je čas podpisovanja enak v obeh primerih, kot je razvidno tudi
iz naše analize na sliki~\ref{fig:podpisovanje} (kjer smo zanemarili čas komunikacije).


\begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\textwidth]{images/benchmark_Signing.pdf}
  \caption[Podpisovanje.]{Primerjava časov podpisovanja pri navadnem in večstranskem
    Schnorrovem podpisu. Prikazan je skupen čas podpisovanja za vse podpisnike.}
  \label{fig:podpisovanje}
\end{figure}

Graf torej odraža čas, ki ga porabi računalnik za računanje, zanemari pa čas komunikacije. Teoretično
je čas za komunikacijo konstanten, če lahko podpisniki hkrati pošljajo in prejemajo več sporočil.
V praksi pa čas zavisi od mnogih pogojev, kot so hitrost povezave, število podpisnikov in stabilnost
povezave.

\subsubsection{Preverjanje}
Ena največjih prednosti večstranskega Schnorrovega podpisa je, da podpis vedno ostane enako dolg kot
navaden podpis – ne glede na število podpisnikov. Edina dodatna naloga preverjevalca je preverjanje
ustreznosti Merklovih korenov, kar pa je hitro in učinkovito.

Navaden Schnorrov podpis zahteva preverjanje vsakega podpisa posebej, kar pomeni, da efektivno
dolžina podpisa raste linearno s številom podpisnikov. To pomeni, da tako raste tudi čas preverjanja.
Prednost večstranskega podpisa lahko vidimo na sliki~\ref{fig:preverjanje}. Zahtevnost preverjanja
navadnega podpisa narašča mnogo hitreje, kot zahtevnost večstranskega. Kljub veliki prednosti
večstranskega Schnorrovega podpisa, vidimo, da zahtevnost vseeno ni konstantna, temveč tudi
linearno narašča. To je zato, ker implementacija podpisa vsakič, ko se podpis preveri, ponovno
konstruira Merklovo drevo. V praksi to za zaporedne podpise enakih skupin ne bi bilo potrebno,
saj bi preverjevalec enostavno lahko shranil Merklovo drevo, kar pomeni, da bi bilo preverjanje še
toliko bolj učinkovito.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\textwidth]{images/benchmark_Verification.pdf}
  \caption[Preverjanje.]{Primerjava časov preverjanja veljavnosti podpisov pri navadnem in večstranskem
    Schnorrovem podpisu. Prikazan je skupen čas preverjanja za vse podpisnike.}
  \label{fig:preverjanje}
\end{figure}

\subsubsection{Celotni podpis}
Če združimo vse operacije -- torej generiranje ključev, podpisovanje in preverjanje -- je enostranski
podpis vseeno učinkovitejši, ker večstranski Schnorrov podpis zahteva veliko računanja za generiranje
ključev. To se jasno vidi na sliki~\ref{fig:celotni}. Seveda pa je to nekoliko nerealistična primerjava,
saj nas redko zanima celoten čas, ki ga bodo porabili različni deležniki. Kljub temu nam da dobro
predstavo o tem, kako se čas podpisovanja različnih podpisov spreminja s številom podpisnikov in kako
na ta čas vplivajo posamezne operacije podpisa.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\textwidth]{images/benchmark_All.pdf}
  \caption[Celotni podpis.]{Primerjava časov celotnega postopka izvedbe podpisne sheme pri navadnem
      in večstranskem Schnorrovem podpisu. Prikazan je skupen čas celotnega postopka za vse
      podpisnike.}
  \label{fig:celotni}
\end{figure}

Za konec lahko analiziramo še situacijo, kjer se ista skupina podpisuje večkrat, torej lahko zanemarimo
čas generiranja ključev. Slika~\ref{fig:podpis-preverjanje} jasno prikaže prednost večstranskega
podpisa v tem primeru.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\textwidth]{images/benchmark_SigningVerification.pdf}
  \caption[Podpisovanje in preverjanje.]{Primerjava časov podpisovanja in preverjanja veljavnosti
    podpisov pri navadnem in večstranskem Schnorrovem podpisu. Prikazan je skupen čas podpisovanja
    in preverjanja za vse podpisnike.}
  \label{fig:podpis-preverjanje}
\end{figure}

\subsection{Razprava}
Na podlagi rezultatov vidimo, da je večstranski Schnorrov podpis lahko zelo uporabno orodje, če so
izpolnjeni določeni pogoji: omejiti želimo delo za preverjevalca in imamo veliko skupino ljudi, ki
se večkrat skupaj podpisuje. Pri obeh vrstah podpisov je vredno omembe, da časovna zahtevnost narašča
linearno s številom podpisnikov za vse operacije.

Kljub učinkovitosti pri preverjanju, ima večstranski Schnorrov podpis tudi nekatere pomanjkljivosti.
Prva je kompleksnost generiranja ključev, ki zahteva interaktivno izmenjavo dokazov znanja in
preverjanje Merklovega drevesa, kar je zamudno in težko optimizirati za zelo velike skupine.
Druga težava je potreba po usklajeni komunikaciji pri podpisovanju. Ker so za vsak podpis potrebni trije
komunikacijski krogi, je to lahko velik strošek v omrežjih z visoko zakasnitvijo ali nizko zanesljivostjo.

Izboljšali bi lahko tudi našo implementacijo: trenutno ne upoštevamo časa, ki se porabi za
komunikacijo med podpisniki, kar je seveda lahko velik faktor. Tako smo se odločili, ker je glavna
prednost večstranskih podpisov preverjanje, ki pa ne zahteva komunikacije. Prav tako bi lahko
natančneje analizirali majhne spremembe pri posotpku, kot je na primer shranjevanje Merklovega drevesa
med zaporednimi podpisi. Ta izboljšava bi jasno pokazala konstantnost časa preverjanja.


\section{Sodobni pristopi k večstranskim podpisom}
\label{sec:sodobno}

\subsection{Varnost večstranskih podpisov v splošnem}
\label{sec:varnost}
Potreba po učinkovitosti je pripeljala avtorje do podpisov, ki potrebujejo le dva kroga. Potem je 
Drijvers pokazal, da so vse take sheme nevarne.

\subsection{MuSig2}
\label{sec:musig2}
Zaradi nedavne popularizacije Schnorrovega podpisa se je zelo veliko dela vložilo v razvoj večstranskega
podpisa, ki vrača popolnoma enake podpise, kot navaden Schnorrov podpis in je hkrati preverljiv
z navadno Schnorrovo enačbo za preverjanje podpisov~\eqref{eq:schnorr-ver}. 

Prva izboljšava v primerjav z zgoraj definiranim podpisom je bila odstranitev enega izmed krogov
podpisovanja. To predstavlja bistveno izboljšavo pri hitrosti podpisovanja, saj je komunikacija
med podpisniki daleč najdražja operacija. Prvih nekaj poskusov se je izkazalo za dokazljivo nevarne
(vsaj z uporabo standardnih metod)~\cite{drijvers2019security}. Z uporabo vpogledov iz dokaza pa je 
Jonasu, Ruffingu in Seurinu~\cite{jonas2020musig2} uspelo narediti podpis, ki lahko enostavno zamenja
Schnorrovega, je ućinkovit in dokazano varen v modelu slučajnega oraklja.

\subsection{Konstrukcija}
Podpis MuSig2 temelji na enaki naivni shemi, kot večstranski Schnorrov podpis. Večstranski Schnorrov
podpis je glavno težavo naivne konstrukcije, torej napad na generiranje ključev, reševal z zahtevo
po priložitvi dokaza znanja brez razkritja znanja o privatnih ključih posameznikov. To je pomenilo
velike izgube, kar se tiče učinkovitosti podpisovanja in velikosti ključev.

% \section{Tehnični napotki za pisanje}
%
% \subsection{Sklicevanje in citiranje}
% Za sklice uporabljamo \verb|\ref|, za sklice na enačbe \verb|\eqref|, za citate \verb|\cite|. Pri
% sklicevanju in citiranju sklicano številko povežemo s prejšnjo besedo z nedeljivim presledkom
% $\sim$, kot npr.\ \verb|iz trditve~\ref{trd:obstoj-omega} vidimo|.
%
% \begin{primer}
%   Zaporedje~\eqref{eq:zero-kompleks} iz dokaza trditve~\ref{trd:obstoj-omega} na
%   strani~\pageref{trd:obstoj-omega} lahko najdemo tudi v Spletni enciklopediji zaporedij~\cite{oeis}.
%   Citiramo lahko tudi bolj natančno~\cite[trditev 2.1, str.\ 23]{lebedev2009introduction}.
% \end{primer}
%
% \subsection{Okrajšave}
% Pri uporabi okrajšav \LaTeX{} za piko vstavi predolg presledek, kot npr. tukaj. Zato se za vsako
% piko, ki ni konec stavka doda presledek običajne širine z ukazom \verb*|\ |, kot npr.\ tukaj.
% Primerjaj z okrajšavo zgoraj za razliko.
%
% \subsection{Vstavljanje slik}
% Sliko vstavimo v plavajočem okolju \texttt{figure}. Plavajoča okolja \emph{plavajo} po tekstu, in
% jih lahko postavimo na vrh strani z opcijskim parametrom `\texttt{t}', na lokacijo, kjer je v kodi s
% `\texttt{h}', in če to ne deluje, potem pa lahko rečete \LaTeX u, da ga \emph{res} želite tukaj,
% kjer ste napisali, s `\texttt{h!}'. Lepo je da so vstavljene slike vektorske (recimo \texttt{.pdf}
% ali \texttt{.eps} ali \texttt{.svg}) ali pa \texttt{.png} visoke resolucije (več kot
% \unit[300]{dpi}).  Pod vsako sliko je napis in na vsako sliko se skličemo v besedilu. Primer
% vektorske slike je na sliki~\ref{fig:sample}. Vektorsko sliko prepoznate tako, da močno
% zoomate v sliko, in še vedno ostane gladka. Več informacij je na voljo na
% \url{https://en.wikibooks.org/wiki/LaTeX/Floats,_Figures_and_Captions}. Če so slike bitne, kot na
% primer slika~\ref{fig:image}, poskrbite, da so v dovolj visoki resoluciji.
%
% \begin{figure}[h]
%   \centering
%   \includegraphics[width=0.6\textwidth]{images/sample.pdf}
% % \caption[caption za v kazalo]{Dolg caption pod sliko}
%   \caption[Primer vektorske slike.]{Primer vektorske slike z oznakami v enaki pisavi, kot jo
%      uporablja \LaTeX{}.  Narejena je s programom Inkscape, \LaTeX{} oznake so importane v
%      Inkscape iz pomožnega PDF.}
%   \label{fig:sample}
% \end{figure}
%
% \begin{figure}[h]
%   \centering
%   \includegraphics[width=0.8\textwidth]{images/image.png}
%   \caption[Primer bitne slike.]{Primer bitne slike, izvožene iz Matlaba. Poskrbite, da so slike v
%   dovolj visoki resoluciji in da ne vsebujejo prosojnih elementov (to zahteva PDF/A-1b format).}
%   \label{fig:image}
% \end{figure}
%
% \subsection{Kako narediti stvarno kazalo}
% Dodate ukaze \verb|\index{polje}| na besede, kjer je pojavijo, kot tukaj\index{tukaj}.
% Več o stvarnih kazalih je na voljo na \url{https://en.wikibooks.org/wiki/LaTeX/Indexing}.
%
% \subsection{Navajanje literature}
% Članke citiramo z uporabo \verb|\cite{label}|, \verb|\cite[text]{label}| ali pa več naenkrat s
% \verb|\cite\{label1, label2}|. Tudi tukaj predhodno besedo in citat povežemo z nedeljivim presledkom
% $\sim$. Na primer~\cite{chen2006meshless,liu2001point}, ali pa \cite{kibriya2007empirical}, ali pa
% \cite[str.\ 12]{trobec2015parallel}, \cite[enačba (2.3)]{pereira2016convergence}.
% Vnosi iz \verb|.bib| datoteke, ki niso citirani, se ne prikažejo v seznamu literature, zato jih
% tukaj citiram.~\cite{vene2000categorical}, \cite{gregoric2017stopniceni}, \cite{slak2015induktivni},
% \cite{nsphere}, \cite{kearsley1975linearly}, \cite{STtemplate}, \cite{NunbergerTand}, \cite{vanoosten2008realizability}.

\end{document}
